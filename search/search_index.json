{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to LibLevelGen \u00b6 What's LibLevelGen? \u00b6 LibLevelGen is a library mod which aims to provide a level generation API for Crypt of the Necrodancer: SYNCHRONY . It can be installed using the built-in mod portal. To try it out, check out the introduction and other resources on this site. Join the Synchrony Discord if you have any questions or just want to hang out!","title":"Welcome to LibLevelGen"},{"location":"#welcome-to-liblevelgen","text":"","title":"Welcome to LibLevelGen"},{"location":"#whats-liblevelgen","text":"LibLevelGen is a library mod which aims to provide a level generation API for Crypt of the Necrodancer: SYNCHRONY . It can be installed using the built-in mod portal. To try it out, check out the introduction and other resources on this site. Join the Synchrony Discord if you have any questions or just want to hang out!","title":"What's LibLevelGen?"},{"location":"getting-started/01-introduction/","text":"01. Introduction \u00b6 LibLevelGen aims to provide an easy to use API to make level generation accessible to all, while still exposing advanced functions for people looking to do very specific things in their levels. In this section, we'll go over what you need to understand the API and the basics. Prerequisites \u00b6 The tutorials here assume you're already familiar with the following: creating a simple Necrodancer (Synchrony) mod, basic lua programming, (very) basic understanding of object-oriented programming concepts. I know it may seem tempting to go on with the tutorial despite not knowing these things, but keep in mind that some stuff may seem confusing if you do that. Anyhow, let's get started! Main concepts \u00b6 If you've done Synchrony modding before, you're probably familiar with the ecs, components, entities, etc... However, we won't actually be using any of that here. This is because of how the level loading pipeline works: first, once the the level transition is initialized, the host generates the level in a special serializable format, then, that level data is sent to other players if we're playing an online session, finally, the level data is interpreted, and all the tiles and entities are placed. What this means is that no tiles and entities are actually getting placed until the last step! Because of that, all the things you normally do to spawn entities like object.spawn do not apply here. LibLevelGen does the work on the first step here - generating the level in the serializable format. It's actually similar to the built-in LevelBuilder module, which in a way is a \"lite\" version of LibLevelGen. You might think it's used internally here, but that's actually not the case - LevelBuilder is the one that was created later, even though it was released first. The instance, the segments, the rooms and more! \u00b6 LibLevelGen uses basic object-oriented programming to create its API. Generally speaking, there exists a hierarchy of object: an instance is a bit of an abstract concept and serves as the \"root\" of the level - it provides some utility methods and holds all other objects (most indirectly), as well as some level metadata such as the music set to play in the level. a segment is essentially some isolated part of the level. It will be explained later a bit more, though you might be familiar with it already since it directly translates to segments used during gameplay. A list of all segments in the level is kept in the instance . a room is a single rectangular area in a segment , which has the top-left corner in the given x and y coordinates and specific width and height . Rooms are stored in a segment . a tile is, well, a single tile. Tiles are kept in a room object, but unlike the previous objects which had no limit, a room can only have a specific amount of tiles - room.w * room.h . Rooms are also initialized with all the tile objects created immidiately, so you don't have to worry about checking whether a tile at the given coordinates exists or not (unless these coordinates are not in the room). finally, there's the entity object. These represent entities that will be spawned once the level is loaded, and are stored in a tile object. In other words, an instance can have an arbitrary amount of segment objects, a segment can have an arbitrary amount of rooms , rooms have a set amount of tiles and tiles can have entities . Hopefully, it should be pretty intuitive. In the next part, we'll go over registering a new level generator, and creating all these objects mentioned above!","title":"01. Introduction"},{"location":"getting-started/01-introduction/#01-introduction","text":"LibLevelGen aims to provide an easy to use API to make level generation accessible to all, while still exposing advanced functions for people looking to do very specific things in their levels. In this section, we'll go over what you need to understand the API and the basics.","title":"01. Introduction"},{"location":"getting-started/01-introduction/#prerequisites","text":"The tutorials here assume you're already familiar with the following: creating a simple Necrodancer (Synchrony) mod, basic lua programming, (very) basic understanding of object-oriented programming concepts. I know it may seem tempting to go on with the tutorial despite not knowing these things, but keep in mind that some stuff may seem confusing if you do that. Anyhow, let's get started!","title":"Prerequisites"},{"location":"getting-started/01-introduction/#main-concepts","text":"If you've done Synchrony modding before, you're probably familiar with the ecs, components, entities, etc... However, we won't actually be using any of that here. This is because of how the level loading pipeline works: first, once the the level transition is initialized, the host generates the level in a special serializable format, then, that level data is sent to other players if we're playing an online session, finally, the level data is interpreted, and all the tiles and entities are placed. What this means is that no tiles and entities are actually getting placed until the last step! Because of that, all the things you normally do to spawn entities like object.spawn do not apply here. LibLevelGen does the work on the first step here - generating the level in the serializable format. It's actually similar to the built-in LevelBuilder module, which in a way is a \"lite\" version of LibLevelGen. You might think it's used internally here, but that's actually not the case - LevelBuilder is the one that was created later, even though it was released first.","title":"Main concepts"},{"location":"getting-started/01-introduction/#the-instance-the-segments-the-rooms-and-more","text":"LibLevelGen uses basic object-oriented programming to create its API. Generally speaking, there exists a hierarchy of object: an instance is a bit of an abstract concept and serves as the \"root\" of the level - it provides some utility methods and holds all other objects (most indirectly), as well as some level metadata such as the music set to play in the level. a segment is essentially some isolated part of the level. It will be explained later a bit more, though you might be familiar with it already since it directly translates to segments used during gameplay. A list of all segments in the level is kept in the instance . a room is a single rectangular area in a segment , which has the top-left corner in the given x and y coordinates and specific width and height . Rooms are stored in a segment . a tile is, well, a single tile. Tiles are kept in a room object, but unlike the previous objects which had no limit, a room can only have a specific amount of tiles - room.w * room.h . Rooms are also initialized with all the tile objects created immidiately, so you don't have to worry about checking whether a tile at the given coordinates exists or not (unless these coordinates are not in the room). finally, there's the entity object. These represent entities that will be spawned once the level is loaded, and are stored in a tile object. In other words, an instance can have an arbitrary amount of segment objects, a segment can have an arbitrary amount of rooms , rooms have a set amount of tiles and tiles can have entities . Hopefully, it should be pretty intuitive. In the next part, we'll go over registering a new level generator, and creating all these objects mentioned above!","title":"The instance, the segments, the rooms and more!"},{"location":"getting-started/02-basics/","text":"02. The basics \u00b6 To get started, you need to install LibLevelGen (perhaps unsuprisingly). It's available on mod.io and through the in-game mod browser. Setting up a mod for testing \u00b6 Once you have it, you can create a new mod that we'll use for testing (the one used throughout the tutorial will be called LibLevelGen Playground ). I also recommend adding LibLevelGen_io_2421628 as a depencency like so: { \"namespace\" : \"LibLevelGenPlayground\" , \"displayName\" : \"LibLevelGen Playground\" , \"version\" : \"1.0.0\" , \"description\" : \"No description given.\" , \"author\" : \"You\" , \"dependencies\" : { \"LibLevelGen_io_2421628\" : \"1.0.0\" }, \"api\" : { \"scriptPath\" : \"\" }, \"icon\" : \"LibLevelGenPlaygroundIcon.png\" , \"banner\" : \"LibLevelGenPlaygroundBanner.png\" , \"tags\" : [], \"name\" : \"LibLevelGenPlayground\" } Replace 1.0.0 with the latest LibLevelGen version available (see image below): (It's a bit inconvenient right now, but in the feature Synchrony will allow automatically getting the latest available version, and this page will be edited accordingly) Of course, if you don't want to do that, you can just load LibLevelGen manually. But once you decide to release your mod, it's something you should do to prevent other people from running into errors caused by LibLevelGen not being loaded. Generating the first level \u00b6 With all that done, we're finally ready to generate our first level! Now, because LibLevelGen is quite isolated from the rest of the game it's mostly self-contained, so you don't need a ton of require s. For now, we'll actually use just one: local libLevelGen = require \"LibLevelGen.LibLevelGen\" To get things going, we need to do a few things - register the level generator, define a function that generates the level and then invoke the generator. It might sound a bit daunting, but it's actually not bad at all: local libLevelGen = require \"LibLevelGen.LibLevelGen\" local function myGenerator ( genParams ) end libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator ) Just like that, we registered a new level generator and a new game mode that uses our generator! You can find it by going to Extra Modes in the lobby and then to the Start Run! stairs. If we select it now, umm... Well, we get a nice black screen, because we haven't actually generated a level inside of the myGenerator function. Let's go ahead and do that real quick: local function myGenerator ( genParams ) -- Create a new instance, which will hold all the things -- related to the generated level. -- We give it the genParams argument - its type is LibLevelGen.LevelGenerationEventParameters -- (http://priw8.github.io/liblevelgen-doc/modules/LibLevelGen.lua/#liblevelgenlevelgenerationeventparameters) -- This argument is used to adjust certain properties of the level. local instance = libLevelGen . new ( genParams ) -- To place the initial starting room, we need a segment. -- As mentioned earlier, segments are isolated collections of rooms. local mainSegment = instance : createSegment () -- Finally, we can create the starting room. There's a nice helper -- method for that, which makes sure that our room ends up -- where the player spawns! mainSegment : createStartingRoom () -- Once we're done with generating the level, -- we need to call the finalize method. instance : finalize () end And thus, behold! The level! cricket noises Making things a bit easier \u00b6 Now, when you spawned you likely couldn't see the entire level because it's heckin' dark in there (unless your character had a torch). For testing level generation, I recommend having a character that can move with fixed beat and starts with a map. I actually made a mod just for that: DebugBard . It's also advised to set the level restart hotkey to something easy to access, because you'll be using it. Like a lot. My personal preference is the [Space] key. Failmaps \u00b6 Note : in the section below, I mention getting an error message. In the current version of the game, errors in the levelGenerate event only produce an error in the log file. This will be changed to give your favourite red text on the screen in the next version. Now, suppose we did something sad in our generator that causes an error, like calling createSegmen instead of createSegment . If we try to start a level like that, we get an interesting error message: Failmap limit exceeded . What does that mean? It's actually quite simple - LibLevelGen generators are allowed to fail, up to 100 times in a row. These failures are called \"failmaps\", and they are there to help fight rare edge cases where level might generate successfuly 99.9% of the time but there's that one weird situation when it fails. Instead of identifying it, we can just pretend it doesn't exist and try again (which is probably not the best advice for programming in general, but I find it a valid strategy for level generation. The base game actually has failmaps too!). However, this behaviour is generally not desirable when actually making the generator. This is why you can disable it in the settings: Options -> Mod Options -> LibLevelGen. With failmap retry disabled, we get the actual error: attempt to call method createSegmen (a nil value) . That's everything for now. In the next part, you'll learn how to make a level that resembles a level a bit more!","title":"02. The basics"},{"location":"getting-started/02-basics/#02-the-basics","text":"To get started, you need to install LibLevelGen (perhaps unsuprisingly). It's available on mod.io and through the in-game mod browser.","title":"02. The basics"},{"location":"getting-started/02-basics/#setting-up-a-mod-for-testing","text":"Once you have it, you can create a new mod that we'll use for testing (the one used throughout the tutorial will be called LibLevelGen Playground ). I also recommend adding LibLevelGen_io_2421628 as a depencency like so: { \"namespace\" : \"LibLevelGenPlayground\" , \"displayName\" : \"LibLevelGen Playground\" , \"version\" : \"1.0.0\" , \"description\" : \"No description given.\" , \"author\" : \"You\" , \"dependencies\" : { \"LibLevelGen_io_2421628\" : \"1.0.0\" }, \"api\" : { \"scriptPath\" : \"\" }, \"icon\" : \"LibLevelGenPlaygroundIcon.png\" , \"banner\" : \"LibLevelGenPlaygroundBanner.png\" , \"tags\" : [], \"name\" : \"LibLevelGenPlayground\" } Replace 1.0.0 with the latest LibLevelGen version available (see image below): (It's a bit inconvenient right now, but in the feature Synchrony will allow automatically getting the latest available version, and this page will be edited accordingly) Of course, if you don't want to do that, you can just load LibLevelGen manually. But once you decide to release your mod, it's something you should do to prevent other people from running into errors caused by LibLevelGen not being loaded.","title":"Setting up a mod for testing"},{"location":"getting-started/02-basics/#generating-the-first-level","text":"With all that done, we're finally ready to generate our first level! Now, because LibLevelGen is quite isolated from the rest of the game it's mostly self-contained, so you don't need a ton of require s. For now, we'll actually use just one: local libLevelGen = require \"LibLevelGen.LibLevelGen\" To get things going, we need to do a few things - register the level generator, define a function that generates the level and then invoke the generator. It might sound a bit daunting, but it's actually not bad at all: local libLevelGen = require \"LibLevelGen.LibLevelGen\" local function myGenerator ( genParams ) end libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator ) Just like that, we registered a new level generator and a new game mode that uses our generator! You can find it by going to Extra Modes in the lobby and then to the Start Run! stairs. If we select it now, umm... Well, we get a nice black screen, because we haven't actually generated a level inside of the myGenerator function. Let's go ahead and do that real quick: local function myGenerator ( genParams ) -- Create a new instance, which will hold all the things -- related to the generated level. -- We give it the genParams argument - its type is LibLevelGen.LevelGenerationEventParameters -- (http://priw8.github.io/liblevelgen-doc/modules/LibLevelGen.lua/#liblevelgenlevelgenerationeventparameters) -- This argument is used to adjust certain properties of the level. local instance = libLevelGen . new ( genParams ) -- To place the initial starting room, we need a segment. -- As mentioned earlier, segments are isolated collections of rooms. local mainSegment = instance : createSegment () -- Finally, we can create the starting room. There's a nice helper -- method for that, which makes sure that our room ends up -- where the player spawns! mainSegment : createStartingRoom () -- Once we're done with generating the level, -- we need to call the finalize method. instance : finalize () end And thus, behold! The level! cricket noises","title":"Generating the first level"},{"location":"getting-started/02-basics/#making-things-a-bit-easier","text":"Now, when you spawned you likely couldn't see the entire level because it's heckin' dark in there (unless your character had a torch). For testing level generation, I recommend having a character that can move with fixed beat and starts with a map. I actually made a mod just for that: DebugBard . It's also advised to set the level restart hotkey to something easy to access, because you'll be using it. Like a lot. My personal preference is the [Space] key.","title":"Making things a bit easier"},{"location":"getting-started/02-basics/#failmaps","text":"Note : in the section below, I mention getting an error message. In the current version of the game, errors in the levelGenerate event only produce an error in the log file. This will be changed to give your favourite red text on the screen in the next version. Now, suppose we did something sad in our generator that causes an error, like calling createSegmen instead of createSegment . If we try to start a level like that, we get an interesting error message: Failmap limit exceeded . What does that mean? It's actually quite simple - LibLevelGen generators are allowed to fail, up to 100 times in a row. These failures are called \"failmaps\", and they are there to help fight rare edge cases where level might generate successfuly 99.9% of the time but there's that one weird situation when it fails. Instead of identifying it, we can just pretend it doesn't exist and try again (which is probably not the best advice for programming in general, but I find it a valid strategy for level generation. The base game actually has failmaps too!). However, this behaviour is generally not desirable when actually making the generator. This is why you can disable it in the settings: Options -> Mod Options -> LibLevelGen. With failmap retry disabled, we get the actual error: attempt to call method createSegmen (a nil value) . That's everything for now. In the next part, you'll learn how to make a level that resembles a level a bit more!","title":"Failmaps"},{"location":"getting-started/03-more-rooms/","text":"03. Creating more rooms \u00b6 Now that we know the bare basics, it's time to create something more than a sad square. Let's create some more rooms! Using Segment.createRoom \u00b6 Segment.createRoom is the most basic way of creating another room in the segment. Let's start where we left off in the previous part: local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () mainSegment : createStartingRoom () instance : finalize () end Let's place another room below the starting room - to calculate the coordinates needed, we'll use the fact that createStartingRoom returns the created Room object . -- In myGenerator(genParams): local startingRoom = mainSegment : createStartingRoom () local newRoomX = startingRoom . x local newRoomY = startingRoom . y + startingRoom . h local newRoom = mainSegment : createRoom ( newRoomX , newRoomY , 5 , 5 ) You may notice that we specified the room to be 5x5, but the actual area with the floor is only 3x3 - that's because the width and height include the room border wall. If you think that generating an entire level using only this would be immensely painful, you are absolutely correct - but don't worry, LibLevelGen has some more functions in store... Segment.createRandLinkedRoom \u00b6 Now we're entering stuff that's a bit more complicated. createRandLinkedRoom is probably the one most involved method in LibLevelGen, so we first need to get some background on what it actually does. Suppose we want to create a room next to another room, connecting them with a corridor (which is also technically a room). We want the generated room to be next to the origin room in any direction, and we may also want corridor length to be randomized, corridor width to be randomized, room height and width to be randomized, etc... Since we're generating random levels here, we don't know too much about the context either - such as what other rooms might already be occupying some space where the room we want could possibly end up. How many possibilities do we actually have here, and how do we check which ones are valid and won't cause any overlaps? We have to do all sorts of fun checks and calculations to make sure all is good, and it does not sound like a very good time. So, how about we let LibLevelGen do all of this for us? Essentially, createRandLinkedRoom takes an origin room and a list of possible ways to generate it, then randomly picks a one that's valid and generates the room and the corridor (or not, if it doesn't find a one that's valid). But the list of all possible ways to generate a room... How do we actually specify it? Creating RoomGenCombination s \u00b6 So our goal here is to create a whole bunch of these tables, which define the ways in which createRandLinkedRoom is allowed to place the room. It'd be very inconvenient to do this by hand, so there's a helper function that can generate these for us: segment.createRandLinkedRoomParameterCombinations (that sure is a name!). Do note that it's a static function of the module and NOT a method of a Segment object. Let's take a look at how it's used: local segment = require \"LibLevelGen.Segment\" local room = require \"LibLevelGen.Room\" -- The argument is similar to RoomGenCombination, but it uses tables -- of numbers instead of single values. local roomGenCombinations = segment . createRandLinkedRoomParameterCombinations { -- Directions in which the room is allowed to generate. direction = { room . Direction . UP , room . Direction . DOWN , room . Direction . LEFT , room . Direction . RIGHT }, -- Where corridor center is allowed to be relative to the origin room. -- 0.5 is the middle, 0 is left/top and 1 is right or bottom. corridorEntrance = { 0.25 , 0.5 , 0.75 }, -- Same as above, but relative to the generated room. corridorExit = { 0.25 , 0.5 , 0.75 }, -- How thick the corridor is allowed to be. Do note that it takes the border -- into account, so thickness of 3 is actually just 1-floor tile wide. corridorThickness = { 3 }, -- How long is the corridor allowed to be. -- Length of 0 is allowed, and will result in rooms being adjacent. corridorLength = { 0 , 1 , 2 , 3 , 4 }, -- Allowed width values for the generated room. roomWidth = { 6 , 7 , 8 , 9 }, -- Allowed height values for the generated room. roomHeight = { 6 , 7 , 8 , 9 }, } So what ends up in roomGenCombinations is all the ways in which the room is allowed to generate. In this case, it's 4*3*3*1*5*4*4 possible ways, which is a whopping 2880! We can verify that with a quick dbg(#roomGenCombinations) : Because of this, it's advised to only call this function once and then use the result. The easy way to do this is simply not putting it in any function, so that it'll only run when the mod is loaded and keep all the combinations ready. Invoking createRandLinkedRoom \u00b6 With our big table generated, we can finally go ahead and call the method. Here's the full file so far: local libLevelGen = require \"LibLevelGen.LibLevelGen\" local segment = require \"LibLevelGen.Segment\" local room = require \"LibLevelGen.Room\" local roomGenCombinations = segment . createRandLinkedRoomParameterCombinations { direction = { room . Direction . UP , room . Direction . DOWN , room . Direction . LEFT , room . Direction . RIGHT }, corridorEntrance = { 0.25 , 0.5 , 0.75 }, corridorExit = { 0.25 , 0.5 , 0.75 }, corridorThickness = { 3 }, corridorLength = { 0 , 1 , 2 , 3 , 4 }, roomWidth = { 6 , 7 , 8 , 9 }, roomHeight = { 6 , 7 , 8 , 9 }, } local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () local startingRoom = mainSegment : createStartingRoom () -- The 2nd argument here defines whether the room should be -- rotated when placed to the right/left of the room, essentially -- swapping width and height. -- Try setting roomWidth = {9}, roomHeight = {6} and then playing changing -- this value to see what I mean here! local newCorridor , newRoom , newRoomData = mainSegment : createRandLinkedRoom ( startingRoom , false , roomGenCombinations ) instance : finalize () end libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator ) And here are some maps that it generated: Feel free to experiment with the values passed to createRandLinkedRoomParameterCombinations to get a better understanding of what they're doing! And so that's basically createRandLinkedRoom in a nutshell. It might take some time to get used to, but it's also fun to mess around with. Going even further \u00b6 So with this, we can keep calling createRandLinkedRoom with the room we just generated as the 1st parameter, to generate more and more rooms in the level: local startingRoom = mainSegment : createStartingRoom () local currentRoom = startingRoom for i = 1 , 10 , 1 do local newCorridor , newRoom , newRoomData = mainSegment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) currentRoom = newRoom end This is certainly a level, but we can go even further and generate more than 1 connected room per room by using some fun recursion: local function createTwoRooms ( currentRoom , roomsLeft ) if roomsLeft > 0 then local newCorridor1 , newRoom1 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) local newCorridor2 , newRoom2 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) -- Check if the generation didn't fail: if newRoom1 then createTwoRooms ( newRoom1 , roomsLeft - 1 ) end if newRoom2 then createTwoRooms ( newRoom2 , roomsLeft - 1 ) end end end local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () local startingRoom = mainSegment : createStartingRoom () createTwoRooms ( startingRoom , 5 ) instance : finalize () end ...it is big. For extra silliness (and CPU torture) we can set the value to 10 instead of 5. It is so big that the minimap can't fit it And then, by playing with the combinations a bit... { direction = { room . Direction . UP , room . Direction . DOWN , room . Direction . LEFT , room . Direction . RIGHT }, corridorEntrance = { 0.5 }, corridorExit = { 0.5 }, corridorThickness = { 3 }, corridorLength = { 0 , 1 , 2 , 3 , 4 }, roomWidth = { 3 }, roomHeight = { 3 }, } ...we can end up with something completely different! Perhaps we could change createTwoRooms to generate one more room once roomsLeft reaches 0, and use different combinations? This way, we could get some bigger rooms in there, surrounded by this maze of corridors! Feel free to try doing this as an exercise. And that is it for now! Hopefully these examples gave you an idea of what createRandLinkedRoom is capable of - with some combinations and a bit of clever code, it can shape your entire level!","title":"03. Creating more rooms"},{"location":"getting-started/03-more-rooms/#03-creating-more-rooms","text":"Now that we know the bare basics, it's time to create something more than a sad square. Let's create some more rooms!","title":"03. Creating more rooms"},{"location":"getting-started/03-more-rooms/#using-segmentcreateroom","text":"Segment.createRoom is the most basic way of creating another room in the segment. Let's start where we left off in the previous part: local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () mainSegment : createStartingRoom () instance : finalize () end Let's place another room below the starting room - to calculate the coordinates needed, we'll use the fact that createStartingRoom returns the created Room object . -- In myGenerator(genParams): local startingRoom = mainSegment : createStartingRoom () local newRoomX = startingRoom . x local newRoomY = startingRoom . y + startingRoom . h local newRoom = mainSegment : createRoom ( newRoomX , newRoomY , 5 , 5 ) You may notice that we specified the room to be 5x5, but the actual area with the floor is only 3x3 - that's because the width and height include the room border wall. If you think that generating an entire level using only this would be immensely painful, you are absolutely correct - but don't worry, LibLevelGen has some more functions in store...","title":"Using Segment.createRoom"},{"location":"getting-started/03-more-rooms/#segmentcreaterandlinkedroom","text":"Now we're entering stuff that's a bit more complicated. createRandLinkedRoom is probably the one most involved method in LibLevelGen, so we first need to get some background on what it actually does. Suppose we want to create a room next to another room, connecting them with a corridor (which is also technically a room). We want the generated room to be next to the origin room in any direction, and we may also want corridor length to be randomized, corridor width to be randomized, room height and width to be randomized, etc... Since we're generating random levels here, we don't know too much about the context either - such as what other rooms might already be occupying some space where the room we want could possibly end up. How many possibilities do we actually have here, and how do we check which ones are valid and won't cause any overlaps? We have to do all sorts of fun checks and calculations to make sure all is good, and it does not sound like a very good time. So, how about we let LibLevelGen do all of this for us? Essentially, createRandLinkedRoom takes an origin room and a list of possible ways to generate it, then randomly picks a one that's valid and generates the room and the corridor (or not, if it doesn't find a one that's valid). But the list of all possible ways to generate a room... How do we actually specify it?","title":"Segment.createRandLinkedRoom"},{"location":"getting-started/03-more-rooms/#creating-roomgencombinations","text":"So our goal here is to create a whole bunch of these tables, which define the ways in which createRandLinkedRoom is allowed to place the room. It'd be very inconvenient to do this by hand, so there's a helper function that can generate these for us: segment.createRandLinkedRoomParameterCombinations (that sure is a name!). Do note that it's a static function of the module and NOT a method of a Segment object. Let's take a look at how it's used: local segment = require \"LibLevelGen.Segment\" local room = require \"LibLevelGen.Room\" -- The argument is similar to RoomGenCombination, but it uses tables -- of numbers instead of single values. local roomGenCombinations = segment . createRandLinkedRoomParameterCombinations { -- Directions in which the room is allowed to generate. direction = { room . Direction . UP , room . Direction . DOWN , room . Direction . LEFT , room . Direction . RIGHT }, -- Where corridor center is allowed to be relative to the origin room. -- 0.5 is the middle, 0 is left/top and 1 is right or bottom. corridorEntrance = { 0.25 , 0.5 , 0.75 }, -- Same as above, but relative to the generated room. corridorExit = { 0.25 , 0.5 , 0.75 }, -- How thick the corridor is allowed to be. Do note that it takes the border -- into account, so thickness of 3 is actually just 1-floor tile wide. corridorThickness = { 3 }, -- How long is the corridor allowed to be. -- Length of 0 is allowed, and will result in rooms being adjacent. corridorLength = { 0 , 1 , 2 , 3 , 4 }, -- Allowed width values for the generated room. roomWidth = { 6 , 7 , 8 , 9 }, -- Allowed height values for the generated room. roomHeight = { 6 , 7 , 8 , 9 }, } So what ends up in roomGenCombinations is all the ways in which the room is allowed to generate. In this case, it's 4*3*3*1*5*4*4 possible ways, which is a whopping 2880! We can verify that with a quick dbg(#roomGenCombinations) : Because of this, it's advised to only call this function once and then use the result. The easy way to do this is simply not putting it in any function, so that it'll only run when the mod is loaded and keep all the combinations ready.","title":"Creating RoomGenCombinations"},{"location":"getting-started/03-more-rooms/#invoking-createrandlinkedroom","text":"With our big table generated, we can finally go ahead and call the method. Here's the full file so far: local libLevelGen = require \"LibLevelGen.LibLevelGen\" local segment = require \"LibLevelGen.Segment\" local room = require \"LibLevelGen.Room\" local roomGenCombinations = segment . createRandLinkedRoomParameterCombinations { direction = { room . Direction . UP , room . Direction . DOWN , room . Direction . LEFT , room . Direction . RIGHT }, corridorEntrance = { 0.25 , 0.5 , 0.75 }, corridorExit = { 0.25 , 0.5 , 0.75 }, corridorThickness = { 3 }, corridorLength = { 0 , 1 , 2 , 3 , 4 }, roomWidth = { 6 , 7 , 8 , 9 }, roomHeight = { 6 , 7 , 8 , 9 }, } local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () local startingRoom = mainSegment : createStartingRoom () -- The 2nd argument here defines whether the room should be -- rotated when placed to the right/left of the room, essentially -- swapping width and height. -- Try setting roomWidth = {9}, roomHeight = {6} and then playing changing -- this value to see what I mean here! local newCorridor , newRoom , newRoomData = mainSegment : createRandLinkedRoom ( startingRoom , false , roomGenCombinations ) instance : finalize () end libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator ) And here are some maps that it generated: Feel free to experiment with the values passed to createRandLinkedRoomParameterCombinations to get a better understanding of what they're doing! And so that's basically createRandLinkedRoom in a nutshell. It might take some time to get used to, but it's also fun to mess around with.","title":"Invoking createRandLinkedRoom"},{"location":"getting-started/03-more-rooms/#going-even-further","text":"So with this, we can keep calling createRandLinkedRoom with the room we just generated as the 1st parameter, to generate more and more rooms in the level: local startingRoom = mainSegment : createStartingRoom () local currentRoom = startingRoom for i = 1 , 10 , 1 do local newCorridor , newRoom , newRoomData = mainSegment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) currentRoom = newRoom end This is certainly a level, but we can go even further and generate more than 1 connected room per room by using some fun recursion: local function createTwoRooms ( currentRoom , roomsLeft ) if roomsLeft > 0 then local newCorridor1 , newRoom1 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) local newCorridor2 , newRoom2 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) -- Check if the generation didn't fail: if newRoom1 then createTwoRooms ( newRoom1 , roomsLeft - 1 ) end if newRoom2 then createTwoRooms ( newRoom2 , roomsLeft - 1 ) end end end local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () local startingRoom = mainSegment : createStartingRoom () createTwoRooms ( startingRoom , 5 ) instance : finalize () end ...it is big. For extra silliness (and CPU torture) we can set the value to 10 instead of 5. It is so big that the minimap can't fit it And then, by playing with the combinations a bit... { direction = { room . Direction . UP , room . Direction . DOWN , room . Direction . LEFT , room . Direction . RIGHT }, corridorEntrance = { 0.5 }, corridorExit = { 0.5 }, corridorThickness = { 3 }, corridorLength = { 0 , 1 , 2 , 3 , 4 }, roomWidth = { 3 }, roomHeight = { 3 }, } ...we can end up with something completely different! Perhaps we could change createTwoRooms to generate one more room once roomsLeft reaches 0, and use different combinations? This way, we could get some bigger rooms in there, surrounded by this maze of corridors! Feel free to try doing this as an exercise. And that is it for now! Hopefully these examples gave you an idea of what createRandLinkedRoom is capable of - with some combinations and a bit of clever code, it can shape your entire level!","title":"Going even further"},{"location":"getting-started/04-room-types/","text":"04. Placing things in rooms \u00b6 Now we know how to make more rooms than we probably need, but they're all empty and that's pretty boring. For testing, we'll start with this generator, which is a toned-down version of one from the previous part: local libLevelGen = require \"LibLevelGen.LibLevelGen\" local segment = require \"LibLevelGen.Segment\" local room = require \"LibLevelGen.Room\" local roomGenCombinations = segment . createRandLinkedRoomParameterCombinations { direction = { room . Direction . UP , room . Direction . DOWN , room . Direction . LEFT , room . Direction . RIGHT }, corridorEntrance = { 0.25 , 0.5 , 0.75 }, corridorExit = { 0.25 , 0.5 , 0.75 }, corridorThickness = { 3 }, corridorLength = { 0 , 1 , 2 }, roomWidth = { 6 , 7 , 8 , 9 }, roomHeight = { 6 , 7 , 8 , 9 }, } local function createTwoRooms ( currentRoom , roomsLeft ) if roomsLeft > 0 then local newCorridor1 , newRoom1 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) local newCorridor2 , newRoom2 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) -- Check if the generation didn't fail: if newRoom1 then createTwoRooms ( newRoom1 , roomsLeft - 1 ) end if newRoom2 then createTwoRooms ( newRoom2 , roomsLeft - 1 ) end end end local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () local startingRoom = mainSegment : createStartingRoom () createTwoRooms ( startingRoom , 2 ) instance : finalize () end libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator ) Room types \u00b6 As mentioned earlier, a \"room\" in LibLevelGen is a quite wide term - it applies to actual rooms, corridors, secret rooms, vaults and even secret shops! Because of this, we need a way to know which operations we can perform in which room - and this is where room flags come into play. If you check out the link above, you'll see that there's a lot of flags like ALLOW_ENEMY , ALLOW_SHRINE , EXIT and more. These determine what kind of things can be done to the room. For example, an exit room will have ALLOW_ENEMY but not ALLOW_SHRINE , because shrines don't spawn in exit rooms. There's also a second enum, room types , which are just collections of flag. For example, room.Type.EXIT consists of ALLOW_ENEMY , ALLOW_TRAVELRUNE , ALLOW_TORCH , ALLOW_TILE_CONVERSION and EXIT . When creating rooms with createRandLinkedRoom , the corridors get flags set to room.Type.CORRIDOR and the actual rooms to room.Type.REGULAR . Of course, you can then modify the flags to your liking, but these are generally pretty good defaults. There's a method to select all rooms which match given flags: Segment:selectRooms , though often it might be more convenient to use Segment:iterateRooms , which will automatically call the given function for every matching room. Placing entities! \u00b6 Let's run some code for every room which allows enemies, like so: local function placeEnemies ( currentRoom ) dbg ( \"Hello from room at \" , currentRoom . x , currentRoom . y ) -- room.Flag.inspect is a useful debug method that exists for -- every enum automatically. dbg ( \"My flags are: \" , room . Flag . inspect ( currentRoom . flags )) end local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () local startingRoom = mainSegment : createStartingRoom () createTwoRooms ( startingRoom , 2 ) mainSegment : iterateRooms ( room . Flag . ALLOW_ENEMY , placeEnemies ) instance : finalize () end With the current generator, this should run placeEnemies for every non-corridor room except the starting room, which is where we definitely do not want any enemies. Now, let's place some entities in the room: this can be done using a handful of methods, but all of them call Tile:placeEntity in the end: local function placeEnemies ( currentRoom ) currentRoom : getTile ( 1 , 1 ): placeEntity ( \"Skeleton\" ) end This will create a little Skeleton friend in the top-left corner of every room where enemies are allowed. Now, it'd be nicer to place the enemy randomly, and there's actually an entire system for selecting tiles which we'll talk about in the next part. For now, let's just place the skeleton in a corner. A quick reminder though: this does not actually create an actual entity yet , it creates a LibLevelGen Entity object which will then be used to construct the data needed to spawn the entity by the game. But room:getTile(...):placeEntity(...) is a lot of typing, so there's a convenience method to do this with a few less characters: currentRoom : placeEntityAt ( 1 , 1 , \"Skeleton\" ) yes, I am pretty lazy Entity levels \u00b6 So in the base game, different entity levels are defined by just appending a number to the entity name: like Skeleton , Skeleton2 , Skeleton3 and so on. But LibLevelGen actually handles it a bit differently - the level and the type are separate arguments to placeEntity methods. currentRoom : placeEntityAt ( 1 , 1 , \"Skeleton\" , 2 ) -- Yellow Skeleton But why do it like that? You see, LibLevelGen is capable of automatically handling Shrine of War upgrades, Ring of Peace downgrades and other things that affect entity levels. Instead of extracting the entity level and type from the name, they are specified separately for convenience. Though spawning a Skeleton3 will also work, LibLevelGen will not actually know that it's a Skeleton - it will interpret this as an entity with base type called Skeleton3 and level 1 . We'll talk more about enemy upgrades and registering your own, custom entity types in the future. Placing torches \u00b6 Our level could really use some more light, so let's add some torches to it. We could iterate over rooms that have the ALLOW_TORCH flag, but there's actually a convenience function to place a given amount of torches per room: -- In myGenerator function, after placing the rooms... mainSegment : placeWallTorches ( 2 ) Suddenly it's a lot nicer in here, huh? Making an exit room \u00b6 Our level is still missing a pretty crucial part - a way to actually leave it. So first, we need to pick a room that we'll make into an exit room, and ideally it should not be directly adjacent to the starting room. We can do that with modyfing the createTwoRooms function in a clever way: local function createExit ( currentRoom ) dbg ( \"Create an exit room here!\" ) end local function createTwoRooms ( currentRoom , roomsLeft , needsExit ) if roomsLeft > 0 then local newCorridor1 , newRoom1 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) local newCorridor2 , newRoom2 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) -- Check if the generation didn't fail: if newRoom1 then createTwoRooms ( newRoom1 , roomsLeft - 1 , needsExit ) end if newRoom2 then createTwoRooms ( newRoom2 , roomsLeft - 1 , false ) end elseif needsExit then createExit ( currentRoom ) end end And then we add the extra argument we just added to the initial call: -- in myGenerator function createTwoRooms ( startingRoom , 2 , true ) Essentially, the needsExit parameter will only remain true for one of the last rooms generated, so even if we were to change 2 to 5 when calling createTwoRooms we'll still get only one exit room. Of course, you can do this in any other way you'd like. Now, how do we make this room an exit room? local function createExit ( currentRoom ) currentRoom : makeExit { { \"Dragon\" , 1 }, { \"Minotaur\" , 1 } } end Aaaand that's it, this function will do everything for us. As the documentation states: Turn the room into an exit room - set appropriate flags, place the exit stairs and the miniboss. We just need to specify which minibosses it can pick from. It even makes sure that the same miniboss type won't appear 2 floors in a row (unless there's no other choice), and also makes sure to spawn 2 minibosses when Shrine of Boss is active. Wowie! Our level is slowly getting better! In the next part, we'll learn the tile selection system briefly mentioned here.","title":"04. Placing things in rooms"},{"location":"getting-started/04-room-types/#04-placing-things-in-rooms","text":"Now we know how to make more rooms than we probably need, but they're all empty and that's pretty boring. For testing, we'll start with this generator, which is a toned-down version of one from the previous part: local libLevelGen = require \"LibLevelGen.LibLevelGen\" local segment = require \"LibLevelGen.Segment\" local room = require \"LibLevelGen.Room\" local roomGenCombinations = segment . createRandLinkedRoomParameterCombinations { direction = { room . Direction . UP , room . Direction . DOWN , room . Direction . LEFT , room . Direction . RIGHT }, corridorEntrance = { 0.25 , 0.5 , 0.75 }, corridorExit = { 0.25 , 0.5 , 0.75 }, corridorThickness = { 3 }, corridorLength = { 0 , 1 , 2 }, roomWidth = { 6 , 7 , 8 , 9 }, roomHeight = { 6 , 7 , 8 , 9 }, } local function createTwoRooms ( currentRoom , roomsLeft ) if roomsLeft > 0 then local newCorridor1 , newRoom1 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) local newCorridor2 , newRoom2 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) -- Check if the generation didn't fail: if newRoom1 then createTwoRooms ( newRoom1 , roomsLeft - 1 ) end if newRoom2 then createTwoRooms ( newRoom2 , roomsLeft - 1 ) end end end local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () local startingRoom = mainSegment : createStartingRoom () createTwoRooms ( startingRoom , 2 ) instance : finalize () end libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator )","title":"04. Placing things in rooms"},{"location":"getting-started/04-room-types/#room-types","text":"As mentioned earlier, a \"room\" in LibLevelGen is a quite wide term - it applies to actual rooms, corridors, secret rooms, vaults and even secret shops! Because of this, we need a way to know which operations we can perform in which room - and this is where room flags come into play. If you check out the link above, you'll see that there's a lot of flags like ALLOW_ENEMY , ALLOW_SHRINE , EXIT and more. These determine what kind of things can be done to the room. For example, an exit room will have ALLOW_ENEMY but not ALLOW_SHRINE , because shrines don't spawn in exit rooms. There's also a second enum, room types , which are just collections of flag. For example, room.Type.EXIT consists of ALLOW_ENEMY , ALLOW_TRAVELRUNE , ALLOW_TORCH , ALLOW_TILE_CONVERSION and EXIT . When creating rooms with createRandLinkedRoom , the corridors get flags set to room.Type.CORRIDOR and the actual rooms to room.Type.REGULAR . Of course, you can then modify the flags to your liking, but these are generally pretty good defaults. There's a method to select all rooms which match given flags: Segment:selectRooms , though often it might be more convenient to use Segment:iterateRooms , which will automatically call the given function for every matching room.","title":"Room types"},{"location":"getting-started/04-room-types/#placing-entities","text":"Let's run some code for every room which allows enemies, like so: local function placeEnemies ( currentRoom ) dbg ( \"Hello from room at \" , currentRoom . x , currentRoom . y ) -- room.Flag.inspect is a useful debug method that exists for -- every enum automatically. dbg ( \"My flags are: \" , room . Flag . inspect ( currentRoom . flags )) end local function myGenerator ( genParams ) local instance = libLevelGen . new ( genParams ) local mainSegment = instance : createSegment () local startingRoom = mainSegment : createStartingRoom () createTwoRooms ( startingRoom , 2 ) mainSegment : iterateRooms ( room . Flag . ALLOW_ENEMY , placeEnemies ) instance : finalize () end With the current generator, this should run placeEnemies for every non-corridor room except the starting room, which is where we definitely do not want any enemies. Now, let's place some entities in the room: this can be done using a handful of methods, but all of them call Tile:placeEntity in the end: local function placeEnemies ( currentRoom ) currentRoom : getTile ( 1 , 1 ): placeEntity ( \"Skeleton\" ) end This will create a little Skeleton friend in the top-left corner of every room where enemies are allowed. Now, it'd be nicer to place the enemy randomly, and there's actually an entire system for selecting tiles which we'll talk about in the next part. For now, let's just place the skeleton in a corner. A quick reminder though: this does not actually create an actual entity yet , it creates a LibLevelGen Entity object which will then be used to construct the data needed to spawn the entity by the game. But room:getTile(...):placeEntity(...) is a lot of typing, so there's a convenience method to do this with a few less characters: currentRoom : placeEntityAt ( 1 , 1 , \"Skeleton\" ) yes, I am pretty lazy","title":"Placing entities!"},{"location":"getting-started/04-room-types/#entity-levels","text":"So in the base game, different entity levels are defined by just appending a number to the entity name: like Skeleton , Skeleton2 , Skeleton3 and so on. But LibLevelGen actually handles it a bit differently - the level and the type are separate arguments to placeEntity methods. currentRoom : placeEntityAt ( 1 , 1 , \"Skeleton\" , 2 ) -- Yellow Skeleton But why do it like that? You see, LibLevelGen is capable of automatically handling Shrine of War upgrades, Ring of Peace downgrades and other things that affect entity levels. Instead of extracting the entity level and type from the name, they are specified separately for convenience. Though spawning a Skeleton3 will also work, LibLevelGen will not actually know that it's a Skeleton - it will interpret this as an entity with base type called Skeleton3 and level 1 . We'll talk more about enemy upgrades and registering your own, custom entity types in the future.","title":"Entity levels"},{"location":"getting-started/04-room-types/#placing-torches","text":"Our level could really use some more light, so let's add some torches to it. We could iterate over rooms that have the ALLOW_TORCH flag, but there's actually a convenience function to place a given amount of torches per room: -- In myGenerator function, after placing the rooms... mainSegment : placeWallTorches ( 2 ) Suddenly it's a lot nicer in here, huh?","title":"Placing torches"},{"location":"getting-started/04-room-types/#making-an-exit-room","text":"Our level is still missing a pretty crucial part - a way to actually leave it. So first, we need to pick a room that we'll make into an exit room, and ideally it should not be directly adjacent to the starting room. We can do that with modyfing the createTwoRooms function in a clever way: local function createExit ( currentRoom ) dbg ( \"Create an exit room here!\" ) end local function createTwoRooms ( currentRoom , roomsLeft , needsExit ) if roomsLeft > 0 then local newCorridor1 , newRoom1 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) local newCorridor2 , newRoom2 = currentRoom . segment : createRandLinkedRoom ( currentRoom , false , roomGenCombinations ) -- Check if the generation didn't fail: if newRoom1 then createTwoRooms ( newRoom1 , roomsLeft - 1 , needsExit ) end if newRoom2 then createTwoRooms ( newRoom2 , roomsLeft - 1 , false ) end elseif needsExit then createExit ( currentRoom ) end end And then we add the extra argument we just added to the initial call: -- in myGenerator function createTwoRooms ( startingRoom , 2 , true ) Essentially, the needsExit parameter will only remain true for one of the last rooms generated, so even if we were to change 2 to 5 when calling createTwoRooms we'll still get only one exit room. Of course, you can do this in any other way you'd like. Now, how do we make this room an exit room? local function createExit ( currentRoom ) currentRoom : makeExit { { \"Dragon\" , 1 }, { \"Minotaur\" , 1 } } end Aaaand that's it, this function will do everything for us. As the documentation states: Turn the room into an exit room - set appropriate flags, place the exit stairs and the miniboss. We just need to specify which minibosses it can pick from. It even makes sure that the same miniboss type won't appear 2 floors in a row (unless there's no other choice), and also makes sure to spawn 2 minibosses when Shrine of Boss is active. Wowie! Our level is slowly getting better! In the next part, we'll learn the tile selection system briefly mentioned here.","title":"Making an exit room"},{"location":"getting-started/05-tile-requirements/","text":"05. Selecting tiles \u00b6 When we want to place something in a room, be it an enemy or a shrine, we need to make sure that the tile we select is valid - we don't want to place something on top of a wall or another entity. Because of this, there exists a tile selection system. The TileRequirements interface \u00b6 There exists an object type with a whole lot of properties, called LibLevelGen.TileRequirements . If you take a look at it in the link above, you'll notice that there really is a lot! But don't worry, all of them are actually optional, so you only need to specify the ones relevant to you. Let's see how to use it based on some examples; we'll start with this as our initial code, which is more or less what you should have after the previous part (I didn't paste it here directly because it's getting long). We'll use the Room:chooseRandomTile method here, which returns a random tile from the ones matching the requirements in the room: local function placeEnemies ( currentRoom ) local selectedTile = currentRoom : chooseRandomTile { isFloor = true , hasEntity = false } -- In our case, we're sure that there's at least 1 tile -- that fulfils the reqs, but this may not always be true! selectedTile : placeEntity ( \"Skeleton\" , 2 ) end The Skeletons don't start in the corners anymore! We can actually write it in a few less lines of code: local function placeEnemies ( currentRoom ) -- This also does the nil check for us currentRoom : placeEntityRand ({ isFloor = true , hasEntity = false }, \"Skeleton\" , 2 ) end as I said, I'm lazy Generally, writing out the requirements every time you need them may not be the best idea; it's better practice to define a variable containing the requirements so that they can be easily reused. Speaking of which... The helper table \u00b6 Most of the time you do not actually need to write out the tile requirements yourself, because there already exists a decent collection of them built-in! We just need to add a require to use it: -- naming it like this to avoid confusion with the Util -- module from the base game. local levelgenUtil = require \"LibLevelGen.Util\" -- An alias because this name is too long to write every time local tr = levelgenUtil . TileRequirements Now we can go ahead and use it: local function placeEnemies ( currentRoom ) currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , 2 ) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) end This is generally the best way to place entities in most cases. Methods using TileRequirements also include: Tile:meetsRequirements , which checks the given tile and returns a boolean, Room:selectTiles , which returns all tiles that meet the requirements in the room, Room:chooseRandomTile , which returns a random tile matching the requirements, Room:chooseRandomTiles , which returns a given amount of tiles, Room:placeEntityRand , which places an entity on a random tile, Room:spreadTile , which is used for placing things such as water or hot coals. ...and that's basically it. There isn't much more to talk about here, tile requirements are a pretty simple mechanism, but they can greatly simplify your code. As a bonus, you can add a mainSegment:setTileset(\"Zone2\") call right after creating the segment, since all these Zone 1 tiles are getting boring. This will make all placed tiles in the segment use the Zone 2 tileset as the default.","title":"05. Selecting tiles"},{"location":"getting-started/05-tile-requirements/#05-selecting-tiles","text":"When we want to place something in a room, be it an enemy or a shrine, we need to make sure that the tile we select is valid - we don't want to place something on top of a wall or another entity. Because of this, there exists a tile selection system.","title":"05. Selecting tiles"},{"location":"getting-started/05-tile-requirements/#the-tilerequirements-interface","text":"There exists an object type with a whole lot of properties, called LibLevelGen.TileRequirements . If you take a look at it in the link above, you'll notice that there really is a lot! But don't worry, all of them are actually optional, so you only need to specify the ones relevant to you. Let's see how to use it based on some examples; we'll start with this as our initial code, which is more or less what you should have after the previous part (I didn't paste it here directly because it's getting long). We'll use the Room:chooseRandomTile method here, which returns a random tile from the ones matching the requirements in the room: local function placeEnemies ( currentRoom ) local selectedTile = currentRoom : chooseRandomTile { isFloor = true , hasEntity = false } -- In our case, we're sure that there's at least 1 tile -- that fulfils the reqs, but this may not always be true! selectedTile : placeEntity ( \"Skeleton\" , 2 ) end The Skeletons don't start in the corners anymore! We can actually write it in a few less lines of code: local function placeEnemies ( currentRoom ) -- This also does the nil check for us currentRoom : placeEntityRand ({ isFloor = true , hasEntity = false }, \"Skeleton\" , 2 ) end as I said, I'm lazy Generally, writing out the requirements every time you need them may not be the best idea; it's better practice to define a variable containing the requirements so that they can be easily reused. Speaking of which...","title":"The TileRequirements interface"},{"location":"getting-started/05-tile-requirements/#the-helper-table","text":"Most of the time you do not actually need to write out the tile requirements yourself, because there already exists a decent collection of them built-in! We just need to add a require to use it: -- naming it like this to avoid confusion with the Util -- module from the base game. local levelgenUtil = require \"LibLevelGen.Util\" -- An alias because this name is too long to write every time local tr = levelgenUtil . TileRequirements Now we can go ahead and use it: local function placeEnemies ( currentRoom ) currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , 2 ) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) end This is generally the best way to place entities in most cases. Methods using TileRequirements also include: Tile:meetsRequirements , which checks the given tile and returns a boolean, Room:selectTiles , which returns all tiles that meet the requirements in the room, Room:chooseRandomTile , which returns a random tile matching the requirements, Room:chooseRandomTiles , which returns a given amount of tiles, Room:placeEntityRand , which places an entity on a random tile, Room:spreadTile , which is used for placing things such as water or hot coals. ...and that's basically it. There isn't much more to talk about here, tile requirements are a pretty simple mechanism, but they can greatly simplify your code. As a bonus, you can add a mainSegment:setTileset(\"Zone2\") call right after creating the segment, since all these Zone 1 tiles are getting boring. This will make all placed tiles in the segment use the Zone 2 tileset as the default.","title":"The helper table"},{"location":"getting-started/06-level-sequence/","text":"06. Level sequence \u00b6 Note : features discussed here were added in 1.1.0, update if you're using 1.0.0. So far, we focused on generating just 1 level, but usually we want the run to have more. Various things related to how and how many levels are created are defined by the level sequence. We'll start with the code from the previous part . What the level sequence does \u00b6 Things like 1-2 coming after 1-1 aren't actually hardcoded and can be changed by altering the level sequence. The sequence itself is an array of LibLevelGen.LevelGenerationOptions objects, and there's one entry for every level in the run. This object type has a lot of fields, but most of them don't actually need to be set - this is because there's another object of this type that's used as a base, and the values of individual entries from the sequence are merged into the base one. Typically, the \"base\" object will contain things such as mode ID, initial starting characters etc, while the level-specific objects will contain floor/zone/depth numbers, and any additional overrides if applicable. But it is perfectly valid to put floor 3 before floor 2 in the level sequence, even if it doesn't make too much sense. Generating the level sequence \u00b6 We can specify the level sequence gemerator with the sequenceClb field of the configuration of our generator like so: libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { sequenceClb = function ( ev , cfg ) ev . sequence [ # ev . sequence + 1 ] = { floor = 1 , zone = 1 , depth = 1 } end }) The ev parameter is an object of type Event.LevelSequenceUpdate (kinda; it uses LibLevelGen.LevelGenerationOptions instead of LevelGenerator.Options in this context), while cfg is a LibLevelGen.Config . If not specified, a default sequence generator is used, which just puts a bunch of levels with depth=1 and zone=1 where the floor number keeps increasing. With the sequence in the example, the run has only 1 level and then goes to the run summary screen. 1 level is a little boring, so let's add some more... Actually, let's add 2 more require s first: -- Do not confuse with levelSequence module of the base game. local levelSequence = require \"LibLevelGen.LevelSequence\" local boss = require \"necro.game.level.Boss\" Now we can do the thing: libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { maxLevel = 3 , sequenceClb = function ( ev , cfg ) for i = 1 , cfg . maxLevel - 1 do ev . sequence [ # ev . sequence + 1 ] = { floor = i , zone = 1 , depth = 1 } end ev . sequence [ # ev . sequence + 1 ] = { type = levelSequence . BuiltinGenerators . BOSS , boss = boss . Type . CONDUCTOR , floor = cfg . maxLevel , zone = 1 , depth = 1 } end }) So now, since maxLevel is 3, the level sequence consists of floors 1-1 and 1-2 followed by a boss level. But we didn't define a boss generator anywhere, so how is it possible? The secret lies in the type field of a sequence entry, which can completely change what level generator is used, as it overrides the type field in the base object. In this case, we're redirecting the level generation to the built-in boss generator and telling it to generate the conductor fight. And if we head to 1-3... We are, in fact, welcomed by the conductor fight! Sequence templates \u00b6 In the LevelSequence module from LibLevelGen there are some premade level sequence generators that you can use. At the time of writing there are only 2 basic ones, because I just added this feature Let's try using one! libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { levelsPerZone = 2 , zones = 4 , sequenceClb = levelSequence . templateAllZones () }) So now we have 1 floor of our generator followed by a boss, repeated 4 times before the run ends. Pretty neat! And that's about it as far as the level sequence goes. Next time, we'll talk a bit about some built-in LibLevelGen features, generating random numbers and altering generation based on the floor. See you there!","title":"06. Level sequence"},{"location":"getting-started/06-level-sequence/#06-level-sequence","text":"Note : features discussed here were added in 1.1.0, update if you're using 1.0.0. So far, we focused on generating just 1 level, but usually we want the run to have more. Various things related to how and how many levels are created are defined by the level sequence. We'll start with the code from the previous part .","title":"06. Level sequence"},{"location":"getting-started/06-level-sequence/#what-the-level-sequence-does","text":"Things like 1-2 coming after 1-1 aren't actually hardcoded and can be changed by altering the level sequence. The sequence itself is an array of LibLevelGen.LevelGenerationOptions objects, and there's one entry for every level in the run. This object type has a lot of fields, but most of them don't actually need to be set - this is because there's another object of this type that's used as a base, and the values of individual entries from the sequence are merged into the base one. Typically, the \"base\" object will contain things such as mode ID, initial starting characters etc, while the level-specific objects will contain floor/zone/depth numbers, and any additional overrides if applicable. But it is perfectly valid to put floor 3 before floor 2 in the level sequence, even if it doesn't make too much sense.","title":"What the level sequence does"},{"location":"getting-started/06-level-sequence/#generating-the-level-sequence","text":"We can specify the level sequence gemerator with the sequenceClb field of the configuration of our generator like so: libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { sequenceClb = function ( ev , cfg ) ev . sequence [ # ev . sequence + 1 ] = { floor = 1 , zone = 1 , depth = 1 } end }) The ev parameter is an object of type Event.LevelSequenceUpdate (kinda; it uses LibLevelGen.LevelGenerationOptions instead of LevelGenerator.Options in this context), while cfg is a LibLevelGen.Config . If not specified, a default sequence generator is used, which just puts a bunch of levels with depth=1 and zone=1 where the floor number keeps increasing. With the sequence in the example, the run has only 1 level and then goes to the run summary screen. 1 level is a little boring, so let's add some more... Actually, let's add 2 more require s first: -- Do not confuse with levelSequence module of the base game. local levelSequence = require \"LibLevelGen.LevelSequence\" local boss = require \"necro.game.level.Boss\" Now we can do the thing: libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { maxLevel = 3 , sequenceClb = function ( ev , cfg ) for i = 1 , cfg . maxLevel - 1 do ev . sequence [ # ev . sequence + 1 ] = { floor = i , zone = 1 , depth = 1 } end ev . sequence [ # ev . sequence + 1 ] = { type = levelSequence . BuiltinGenerators . BOSS , boss = boss . Type . CONDUCTOR , floor = cfg . maxLevel , zone = 1 , depth = 1 } end }) So now, since maxLevel is 3, the level sequence consists of floors 1-1 and 1-2 followed by a boss level. But we didn't define a boss generator anywhere, so how is it possible? The secret lies in the type field of a sequence entry, which can completely change what level generator is used, as it overrides the type field in the base object. In this case, we're redirecting the level generation to the built-in boss generator and telling it to generate the conductor fight. And if we head to 1-3... We are, in fact, welcomed by the conductor fight!","title":"Generating the level sequence"},{"location":"getting-started/06-level-sequence/#sequence-templates","text":"In the LevelSequence module from LibLevelGen there are some premade level sequence generators that you can use. At the time of writing there are only 2 basic ones, because I just added this feature Let's try using one! libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { levelsPerZone = 2 , zones = 4 , sequenceClb = levelSequence . templateAllZones () }) So now we have 1 floor of our generator followed by a boss, repeated 4 times before the run ends. Pretty neat! And that's about it as far as the level sequence goes. Next time, we'll talk a bit about some built-in LibLevelGen features, generating random numbers and altering generation based on the floor. See you there!","title":"Sequence templates"},{"location":"getting-started/07-small-things/","text":"07. A variety of small things #1 \u00b6 So generally, the most important things have been discussed in the previous part already. Yay! Still, that doesn't mean that there's nothing left to talk about - in fact, there's a whole bunch of small but neat things! Randomness \u00b6 So far, the randomness in our level has been determined by built-in functions, but that doesn't mean we can't generate random numbers ourselves. The code we'll start with is this . Let's try randomizing the levels of the Skeletons we spawn: we'll use instance:randIntRange for this. You should not use the game's built-in RNG module for level generation in LibLevelGen! While it will work, it will make the levels different even on the same seed, unless you specifically set up proper RNG channels youself. local function placeEnemies ( currentRoom ) -- For convenience, objects have a reference to the instance they belong to. local instance = currentRoom . instance -- randIntRange is not inclusive for the 2nd number, so we get numbers from 1 to 3 here. currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( 1 , 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) end Pretty simple so far. Another function we can use is instance:randChoice : local function placeEnemies ( currentRoom ) local instance = currentRoom . instance currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( 1 , 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) local enemyType = instance : randChoice { \"Monkey\" , \"Bat\" , \"Ghost\" } currentRoom : placeEntityRand ( tr . Enemy . Generic , enemyType ) end Now we have 3 enemies per room: a Skeleton, a Spider and a random enemy that's either a Monkey, a Bat or a Ghost. There's also instance:randChance , which returns a boolean: local function placeEnemies ( currentRoom ) local instance = currentRoom . instance currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( 1 , 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) local enemyType = instance : randChoice { \"Monkey\" , \"Bat\" , \"Ghost\" } currentRoom : placeEntityRand ( tr . Enemy . Generic , enemyType ) if instance : randChance ( 0.5 ) then currentRoom : placeEntityRand ( tr . Enemy . MovingSlime , \"Slime\" , 2 ) end end Our rooms now have a 50% to chance to also contain a blue Slime. Notice how tr.Enemy.MovingSlime is used here - it's essentialy the same as Generic , but does not place the entity next to a wall. After all, our Slime would be pretty sad if we spawned it in a way that makes it unable to move, and we do not want to make the Slime sad. Exit rooms typically have extra enemies, so we can throw in some extra ones too: local function placeEnemies ( currentRoom ) local instance = currentRoom . instance currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( 1 , 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) local enemyType = instance : randChoice { \"Monkey\" , \"Bat\" , \"Ghost\" } currentRoom : placeEntityRand ( tr . Enemy . Generic , enemyType ) if instance : randChance ( 0.5 ) then currentRoom : placeEntityRand ( tr . Enemy . MovingSlime , \"Slime\" , 2 ) end if currentRoom : checkFlags ( room . Flag . EXIT ) then currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Monkey\" , 2 ) currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Slime\" ) end end As mentioned in one of the earlier parts, room flags can be used to check for various properties of the room, including whether the room is an exit room. Anyhow, let's leave the placeEnemies function for now. Acquiring entity names \u00b6 Okay, this section is a bit of a detour, but it's worth talking about. So far the entities we placed had fairly intuitive names, but it might not always be the case so it's worth knowing how to find the name of the entity you want. The built-in level editor is of great help here - and you can actually enable it mid-run! To enable the level editor for live-editing, open the menu and go to Customize -> Downloadable Content. Then, use the icon shown below to enable display of individual feature packs: Once you switch this option to \"on\", the feature packs will be displayed: And you can activate the level editor! After doing that, exit the menus and right-click anywhere in the level to open the editor (and press escape to close it): But we're not done yet - to show internal entity names, we need to activate this option in the editor settings: And now finally, we can search for entities. To toggle the category list in the right panel, either press [Tab] on the keyboard or right click that panel. For example, let's go to the Traps category and check the entity name of the all-directional bounce trap: There's a small subtitle telling us that it's called BounceTrapOmni when we hover over it. Cool! The level editor can also be used to preview the level sequence if you go to Dungeon Settings (the Stairs icon in the toolbar), which may be useful for debugging and skipping to given levels. Placing traps \u00b6 Traps are placed in the same way as enemies - let's go ahead and create a placeTraps function: -- in myGenerator function, below the iterateRooms call that calls placeEnemies... mainSegment : iterateRooms ( room . Flag . ALLOW_TRAP , placeTraps ) -- above the myGenerator function local function placeTraps ( currentRoom ) local instance = currentRoom . instance end Similarly to ALLOW_ENEMY , the ALLOW_TRAP flag can be used to check whether the room is suitable for trap placement. In this case it's similar to enemies, but the exit room will not have this flag set because exit rooms normally do not have traps. Either way, time to place some traps; the entity names can be acquired with the method explained above. local function placeTraps ( currentRoom ) local instance = currentRoom . instance local trapTypes = { \"BombTrap\" , \"BounceTrapOmni\" , \"SpikeTrap\" , \"Sync_DiceTrap\" } local trapCount = instance : randIntRange ( 1 , 4 ) for i = 1 , trapCount do currentRoom : placeEntityRand ( tr . Trap . Generic , instance : randChoice ( trapTypes )) end end ...to be honest, this is not exactly ideal - I think the trap count should instead be determined by the size of the room, to prevent small rooms from getting too many traps. I'm not going to do this here to keep things simple, but it's worth keeping room size in mind when placing things in it. Making later floors harder \u00b6 This is actually pretty simple to do - the instance:getFloor() method returns the current floor number, and you can use it to determine various things - for example, let's head back to placeEnemies for a moment and modify it a bit: local function placeEnemies ( currentRoom ) local instance = currentRoom . instance -- ! local floor = instance : getFloor () -- ! currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( math.min ( floor , 3 ), 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) local enemyType = instance : randChoice { \"Monkey\" , \"Bat\" , \"Ghost\" } currentRoom : placeEntityRand ( tr . Enemy . Generic , enemyType ) -- ! if instance : randChance ( 0.5 ) or floor > 2 then currentRoom : placeEntityRand ( tr . Enemy . MovingSlime , \"Slime\" , 2 ) end -- ! if floor > 1 then currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Bat\" , 2 ) end if currentRoom : checkFlags ( room . Flag . EXIT ) then currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Monkey\" , 2 ) currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Slime\" ) end end I marked the modified parts with a ! comment. While changing just the enemies is pretty basic, this is just an example - there is a whole lot more you can do across the entire level! A bunch of automatic things \u00b6 LibLevelGen has a few quite useful options that you can enable: let's add a little thing to our generator configuration... libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { placeShrines = true , -- !!! levelsPerZone = 4 , zones = 4 , sequenceClb = levelSequence . templateAllZones () }) And just like that, LibLevelGen will place shrines automatically in every zone: Note : this feature had a bug in versions 1.0.0 and 1.1.0, update to 1.1.1 or later should issues occur. The same can be done with secret shops: libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { placeShrines = true , placeSecretShops = true , -- !!! levelsPerZone = 4 , zones = 4 , sequenceClb = levelSequence . templateAllZones () }) You can even define your own shrines and shop types to be placed, but we'll talk about it later (since it's a bit more advanced). There's more things like this, but I think this part is long enough by now - to be continued...","title":"07. A variety of small things #1"},{"location":"getting-started/07-small-things/#07-a-variety-of-small-things-1","text":"So generally, the most important things have been discussed in the previous part already. Yay! Still, that doesn't mean that there's nothing left to talk about - in fact, there's a whole bunch of small but neat things!","title":"07. A variety of small things #1"},{"location":"getting-started/07-small-things/#randomness","text":"So far, the randomness in our level has been determined by built-in functions, but that doesn't mean we can't generate random numbers ourselves. The code we'll start with is this . Let's try randomizing the levels of the Skeletons we spawn: we'll use instance:randIntRange for this. You should not use the game's built-in RNG module for level generation in LibLevelGen! While it will work, it will make the levels different even on the same seed, unless you specifically set up proper RNG channels youself. local function placeEnemies ( currentRoom ) -- For convenience, objects have a reference to the instance they belong to. local instance = currentRoom . instance -- randIntRange is not inclusive for the 2nd number, so we get numbers from 1 to 3 here. currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( 1 , 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) end Pretty simple so far. Another function we can use is instance:randChoice : local function placeEnemies ( currentRoom ) local instance = currentRoom . instance currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( 1 , 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) local enemyType = instance : randChoice { \"Monkey\" , \"Bat\" , \"Ghost\" } currentRoom : placeEntityRand ( tr . Enemy . Generic , enemyType ) end Now we have 3 enemies per room: a Skeleton, a Spider and a random enemy that's either a Monkey, a Bat or a Ghost. There's also instance:randChance , which returns a boolean: local function placeEnemies ( currentRoom ) local instance = currentRoom . instance currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( 1 , 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) local enemyType = instance : randChoice { \"Monkey\" , \"Bat\" , \"Ghost\" } currentRoom : placeEntityRand ( tr . Enemy . Generic , enemyType ) if instance : randChance ( 0.5 ) then currentRoom : placeEntityRand ( tr . Enemy . MovingSlime , \"Slime\" , 2 ) end end Our rooms now have a 50% to chance to also contain a blue Slime. Notice how tr.Enemy.MovingSlime is used here - it's essentialy the same as Generic , but does not place the entity next to a wall. After all, our Slime would be pretty sad if we spawned it in a way that makes it unable to move, and we do not want to make the Slime sad. Exit rooms typically have extra enemies, so we can throw in some extra ones too: local function placeEnemies ( currentRoom ) local instance = currentRoom . instance currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( 1 , 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) local enemyType = instance : randChoice { \"Monkey\" , \"Bat\" , \"Ghost\" } currentRoom : placeEntityRand ( tr . Enemy . Generic , enemyType ) if instance : randChance ( 0.5 ) then currentRoom : placeEntityRand ( tr . Enemy . MovingSlime , \"Slime\" , 2 ) end if currentRoom : checkFlags ( room . Flag . EXIT ) then currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Monkey\" , 2 ) currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Slime\" ) end end As mentioned in one of the earlier parts, room flags can be used to check for various properties of the room, including whether the room is an exit room. Anyhow, let's leave the placeEnemies function for now.","title":"Randomness"},{"location":"getting-started/07-small-things/#acquiring-entity-names","text":"Okay, this section is a bit of a detour, but it's worth talking about. So far the entities we placed had fairly intuitive names, but it might not always be the case so it's worth knowing how to find the name of the entity you want. The built-in level editor is of great help here - and you can actually enable it mid-run! To enable the level editor for live-editing, open the menu and go to Customize -> Downloadable Content. Then, use the icon shown below to enable display of individual feature packs: Once you switch this option to \"on\", the feature packs will be displayed: And you can activate the level editor! After doing that, exit the menus and right-click anywhere in the level to open the editor (and press escape to close it): But we're not done yet - to show internal entity names, we need to activate this option in the editor settings: And now finally, we can search for entities. To toggle the category list in the right panel, either press [Tab] on the keyboard or right click that panel. For example, let's go to the Traps category and check the entity name of the all-directional bounce trap: There's a small subtitle telling us that it's called BounceTrapOmni when we hover over it. Cool! The level editor can also be used to preview the level sequence if you go to Dungeon Settings (the Stairs icon in the toolbar), which may be useful for debugging and skipping to given levels.","title":"Acquiring entity names"},{"location":"getting-started/07-small-things/#placing-traps","text":"Traps are placed in the same way as enemies - let's go ahead and create a placeTraps function: -- in myGenerator function, below the iterateRooms call that calls placeEnemies... mainSegment : iterateRooms ( room . Flag . ALLOW_TRAP , placeTraps ) -- above the myGenerator function local function placeTraps ( currentRoom ) local instance = currentRoom . instance end Similarly to ALLOW_ENEMY , the ALLOW_TRAP flag can be used to check whether the room is suitable for trap placement. In this case it's similar to enemies, but the exit room will not have this flag set because exit rooms normally do not have traps. Either way, time to place some traps; the entity names can be acquired with the method explained above. local function placeTraps ( currentRoom ) local instance = currentRoom . instance local trapTypes = { \"BombTrap\" , \"BounceTrapOmni\" , \"SpikeTrap\" , \"Sync_DiceTrap\" } local trapCount = instance : randIntRange ( 1 , 4 ) for i = 1 , trapCount do currentRoom : placeEntityRand ( tr . Trap . Generic , instance : randChoice ( trapTypes )) end end ...to be honest, this is not exactly ideal - I think the trap count should instead be determined by the size of the room, to prevent small rooms from getting too many traps. I'm not going to do this here to keep things simple, but it's worth keeping room size in mind when placing things in it.","title":"Placing traps"},{"location":"getting-started/07-small-things/#making-later-floors-harder","text":"This is actually pretty simple to do - the instance:getFloor() method returns the current floor number, and you can use it to determine various things - for example, let's head back to placeEnemies for a moment and modify it a bit: local function placeEnemies ( currentRoom ) local instance = currentRoom . instance -- ! local floor = instance : getFloor () -- ! currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Skeleton\" , instance : randIntRange ( math.min ( floor , 3 ), 4 )) currentRoom : placeEntityRand ( tr . Enemy . OnWall , \"Spider\" ) local enemyType = instance : randChoice { \"Monkey\" , \"Bat\" , \"Ghost\" } currentRoom : placeEntityRand ( tr . Enemy . Generic , enemyType ) -- ! if instance : randChance ( 0.5 ) or floor > 2 then currentRoom : placeEntityRand ( tr . Enemy . MovingSlime , \"Slime\" , 2 ) end -- ! if floor > 1 then currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Bat\" , 2 ) end if currentRoom : checkFlags ( room . Flag . EXIT ) then currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Monkey\" , 2 ) currentRoom : placeEntityRand ( tr . Enemy . Generic , \"Slime\" ) end end I marked the modified parts with a ! comment. While changing just the enemies is pretty basic, this is just an example - there is a whole lot more you can do across the entire level!","title":"Making later floors harder"},{"location":"getting-started/07-small-things/#a-bunch-of-automatic-things","text":"LibLevelGen has a few quite useful options that you can enable: let's add a little thing to our generator configuration... libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { placeShrines = true , -- !!! levelsPerZone = 4 , zones = 4 , sequenceClb = levelSequence . templateAllZones () }) And just like that, LibLevelGen will place shrines automatically in every zone: Note : this feature had a bug in versions 1.0.0 and 1.1.0, update to 1.1.1 or later should issues occur. The same can be done with secret shops: libLevelGen . registerGenerator ( \"LibLevelGen Playground\" , myGenerator , { placeShrines = true , placeSecretShops = true , -- !!! levelsPerZone = 4 , zones = 4 , sequenceClb = levelSequence . templateAllZones () }) You can even define your own shrines and shop types to be placed, but we'll talk about it later (since it's a bit more advanced). There's more things like this, but I think this part is long enough by now - to be continued...","title":"A bunch of automatic things"},{"location":"modules/Enemy.lua/","text":"Enemy.lua \u00b6 Functions \u00b6 enemy.getData \u00b6 enemy . getData ( type : string ): LibLevelGen . EnemyData Gets LibLevelGen data for the given enemy type. Parameters : Name Type Description type string Type from the enemy.Type enum Returns : LibLevelGen.EnemyData enemy.register \u00b6 enemy . register ( entity : string , maxLevel : number , args : LibLevelGen . EnemyData ): number Register LibLevelGen enemy data in the enemy enum. Parameters : Name Type Description entity string Entity base name maxLevel number Max level this entity can have args LibLevelGen.EnemyData Additional enemy definition data Returns : number Classes \u00b6 LibLevelGen.EnemyData \u00b6 Class containing data related to processing it by the various level generation components. Properties : Name Type Description entity string The base entity type maxLevel number Max level the entity type can have id number[] Numeric IDs for every level the entity has warRingUpgrade table<number,number> Table containing a mapping which specifies which levels get converted to which when ring of war is in effect warShrineUpgrade table<number,number> Table containing a mapping which specifies which levels get converted to which when shrine of war is in effect peaceRingDowngrade table<number,number> Table containing a mapping which specifies which levels get converted to which when ring of peace is in effect challengeCharacterDowngrade table<number,number> Table containing a mapping which specifies which levels get converted to which when playing a challenge character (Monk/Coda/Aria/Bolt - used to downgrade black bats into blue) Enums \u00b6 enemy.Type \u00b6 Enum containing enemy types and their associated data. Use enemy.getData to get data for a given enemy from this enum. Entries : King CoralRiff KingConga Deathmetal Fortissimole Necrodancer DeadRinger Frankensteinway Conductor LuteDragon Direbat Dragon Banshee Minotaur Nightmare Mommy Ogre Metrognome Armadillo Armoredskeleton Bat Beetle Bishop Blademaster Cauldron Clone Devil ElectricMage Evileye Fireelemental Iceelemental Ghast Ghost Ghoul Goblin GoblinBomber Golem Gorgon Harpy Hellhound Knight Lich Monkey Mushroom Orc Pawn Pixie Queen Rook Sarcophagus Shovemonster Skeleton Skeletonknight Skeletonmage Skull SleepingGoblin Slime Spider Tarmonster Tentacle Trapcouldron Trapchest Troll Warlock WaterBall Wight Wraith Yeti Zombie ZombieElectric ZombieSnake","title":"Enemy.lua"},{"location":"modules/Enemy.lua/#enemylua","text":"","title":"Enemy.lua"},{"location":"modules/Enemy.lua/#functions","text":"","title":"Functions"},{"location":"modules/Enemy.lua/#enemygetdata","text":"enemy . getData ( type : string ): LibLevelGen . EnemyData Gets LibLevelGen data for the given enemy type. Parameters : Name Type Description type string Type from the enemy.Type enum Returns : LibLevelGen.EnemyData","title":"enemy.getData"},{"location":"modules/Enemy.lua/#enemyregister","text":"enemy . register ( entity : string , maxLevel : number , args : LibLevelGen . EnemyData ): number Register LibLevelGen enemy data in the enemy enum. Parameters : Name Type Description entity string Entity base name maxLevel number Max level this entity can have args LibLevelGen.EnemyData Additional enemy definition data Returns : number","title":"enemy.register"},{"location":"modules/Enemy.lua/#classes","text":"","title":"Classes"},{"location":"modules/Enemy.lua/#liblevelgenenemydata","text":"Class containing data related to processing it by the various level generation components. Properties : Name Type Description entity string The base entity type maxLevel number Max level the entity type can have id number[] Numeric IDs for every level the entity has warRingUpgrade table<number,number> Table containing a mapping which specifies which levels get converted to which when ring of war is in effect warShrineUpgrade table<number,number> Table containing a mapping which specifies which levels get converted to which when shrine of war is in effect peaceRingDowngrade table<number,number> Table containing a mapping which specifies which levels get converted to which when ring of peace is in effect challengeCharacterDowngrade table<number,number> Table containing a mapping which specifies which levels get converted to which when playing a challenge character (Monk/Coda/Aria/Bolt - used to downgrade black bats into blue)","title":"LibLevelGen.EnemyData"},{"location":"modules/Enemy.lua/#enums","text":"","title":"Enums"},{"location":"modules/Enemy.lua/#enemytype","text":"Enum containing enemy types and their associated data. Use enemy.getData to get data for a given enemy from this enum. Entries : King CoralRiff KingConga Deathmetal Fortissimole Necrodancer DeadRinger Frankensteinway Conductor LuteDragon Direbat Dragon Banshee Minotaur Nightmare Mommy Ogre Metrognome Armadillo Armoredskeleton Bat Beetle Bishop Blademaster Cauldron Clone Devil ElectricMage Evileye Fireelemental Iceelemental Ghast Ghost Ghoul Goblin GoblinBomber Golem Gorgon Harpy Hellhound Knight Lich Monkey Mushroom Orc Pawn Pixie Queen Rook Sarcophagus Shovemonster Skeleton Skeletonknight Skeletonmage Skull SleepingGoblin Slime Spider Tarmonster Tentacle Trapcouldron Trapchest Troll Warlock WaterBall Wight Wraith Yeti Zombie ZombieElectric ZombieSnake","title":"enemy.Type"},{"location":"modules/Entity.lua/","text":"Entity.lua \u00b6 Functions \u00b6 entity.new \u00b6 entity . new ( instance : LibLegelGen . Instance , type : string , x ? : number , y ? : number , level ? : number | number []): LibLevelGen . Entity Create a new LibLevelGen entity. Do note that instead of using this, you should use methods provided by the LibLevelGen.Room and LibLevelGen.Tile classes, which will place the enemy in the level automatically. Parameters : Name Type Description instance LibLegelGen.Instance Parent instance of the entity type string Entity type x? number X coordinate of the entity, relative to the room it's in. Defaults to -1 y? number Y coordinate of the entity, relative to the room it's in Defaults to -1 level? number | number[] Level of the entity, if a table is specified it's picked randomly from the provided values. Defaults to 1. Returns : LibLevelGen.Entity Classes \u00b6 LibLevelGen.Entity \u00b6 Represents a LibLevelGen entity object Properties : Name Type Description instance LibLegelGen.Instance Instance this entity belongs to type string Entity type x number Entity X coordinate relative, relative to the room it's in y number Entity Y coordinate relative, relative to the room it's in level number Entity level saleCurrency string | nil If entity has a price, this determines the currency price table | nil Entity price data, in the format set by Synchrony's levelUtils.setEntityPriceTag attributes table | nil Additional entity attributes. Use .setAttribute and .getOrCreateAttribute methods to manipulate this table. inventory table | nil Entity's inventory. Use the .giveItem method to manipulate this table. Methods : LibLevelGen.Entity.setAttribute \u00b6 setAttribute ( self : LibLevelGen . Entity , component : string , field : string , value : any ): LibLevelGen . Entity Set value of the given component field for when the entity is spawned. Parameters : Name Type Description self LibLevelGen.Entity The entity component string Component name field string Field in the given component value any Value to write to the field Returns : LibLevelGen.Entity LibLevelGen.Entity.setPrice \u00b6 setPrice ( self : LibLevelGen . Entity , currency ? : \"coins\" | \"blood\" , amount ? : number ): LibLevelGen . Entity Set price of the entity. If price is not specified, it is automatically obtained. Parameters : Name Type Description self LibLevelGen.Entity The Entity currency? \"coins\" | \"blood\" Currency type, defaults to \"coins\" amount? number The price value. If not specified, it's calculated automatically. Returns : LibLevelGen.Entity LibLevelGen.Entity.setDiscount \u00b6 setDiscount ( self : LibLevelGen . Entity , discount : number ): LibLevelGen . Entity Set discount on the price. Parameters : Name Type Description self LibLevelGen.Entity The entity discount number The discount factor. 0.5 will result in the price being halved. Returns : LibLevelGen.Entity LibLevelGen.Entity.setQuantity \u00b6 setQuantity ( self : LibLevelGen . Entity , quantity : number ): LibLevelGen . Entity Set quantity (itemStack.quantity field) Parameters : Name Type Description self LibLevelGen.Entity The entity quantity number The quantity amount to set Returns : LibLevelGen.Entity LibLevelGen.Entity.giveItem \u00b6 giveItem ( self : LibLevelGen . Entity , item : string | LibLevelGen . Entity ): LibLevelGen . Entity Add an item to entity's inventory. Parameters : Name Type Description self LibLevelGen.Entity The entity item string | LibLevelGen.Entity Entity type or an existing entity to add to the inventory. Returns : LibLevelGen.Entity LibLevelGen.Entity.getOrCreateAttribute \u00b6 getOrCreateAttribute ( self : LibLevelGen . Entity , component : string , field : string ): LibLevelGen . Entity Get an attribute of the entity. If it doesn't exist, it gets created and added (with no value specified) Parameters : Name Type Description self LibLevelGen.Entity The entity component string Component name field string Field name in the given component Returns : LibLevelGen.Entity LibLevelGen.Entity.storeItem \u00b6 storeItem ( self : LibLevelGen . Entity , item : string ): LibLevelGen . Entity Add an item to entity's storage. Parameters : Name Type Description self LibLevelGen.Entity The entity item string Item entity type Returns : LibLevelGen.Entity","title":"Entity.lua"},{"location":"modules/Entity.lua/#entitylua","text":"","title":"Entity.lua"},{"location":"modules/Entity.lua/#functions","text":"","title":"Functions"},{"location":"modules/Entity.lua/#entitynew","text":"entity . new ( instance : LibLegelGen . Instance , type : string , x ? : number , y ? : number , level ? : number | number []): LibLevelGen . Entity Create a new LibLevelGen entity. Do note that instead of using this, you should use methods provided by the LibLevelGen.Room and LibLevelGen.Tile classes, which will place the enemy in the level automatically. Parameters : Name Type Description instance LibLegelGen.Instance Parent instance of the entity type string Entity type x? number X coordinate of the entity, relative to the room it's in. Defaults to -1 y? number Y coordinate of the entity, relative to the room it's in Defaults to -1 level? number | number[] Level of the entity, if a table is specified it's picked randomly from the provided values. Defaults to 1. Returns : LibLevelGen.Entity","title":"entity.new"},{"location":"modules/Entity.lua/#classes","text":"","title":"Classes"},{"location":"modules/Entity.lua/#liblevelgenentity","text":"Represents a LibLevelGen entity object Properties : Name Type Description instance LibLegelGen.Instance Instance this entity belongs to type string Entity type x number Entity X coordinate relative, relative to the room it's in y number Entity Y coordinate relative, relative to the room it's in level number Entity level saleCurrency string | nil If entity has a price, this determines the currency price table | nil Entity price data, in the format set by Synchrony's levelUtils.setEntityPriceTag attributes table | nil Additional entity attributes. Use .setAttribute and .getOrCreateAttribute methods to manipulate this table. inventory table | nil Entity's inventory. Use the .giveItem method to manipulate this table. Methods :","title":"LibLevelGen.Entity"},{"location":"modules/Entity.lua/#liblevelgenentitysetattribute","text":"setAttribute ( self : LibLevelGen . Entity , component : string , field : string , value : any ): LibLevelGen . Entity Set value of the given component field for when the entity is spawned. Parameters : Name Type Description self LibLevelGen.Entity The entity component string Component name field string Field in the given component value any Value to write to the field Returns : LibLevelGen.Entity","title":"LibLevelGen.Entity.setAttribute"},{"location":"modules/Entity.lua/#liblevelgenentitysetprice","text":"setPrice ( self : LibLevelGen . Entity , currency ? : \"coins\" | \"blood\" , amount ? : number ): LibLevelGen . Entity Set price of the entity. If price is not specified, it is automatically obtained. Parameters : Name Type Description self LibLevelGen.Entity The Entity currency? \"coins\" | \"blood\" Currency type, defaults to \"coins\" amount? number The price value. If not specified, it's calculated automatically. Returns : LibLevelGen.Entity","title":"LibLevelGen.Entity.setPrice"},{"location":"modules/Entity.lua/#liblevelgenentitysetdiscount","text":"setDiscount ( self : LibLevelGen . Entity , discount : number ): LibLevelGen . Entity Set discount on the price. Parameters : Name Type Description self LibLevelGen.Entity The entity discount number The discount factor. 0.5 will result in the price being halved. Returns : LibLevelGen.Entity","title":"LibLevelGen.Entity.setDiscount"},{"location":"modules/Entity.lua/#liblevelgenentitysetquantity","text":"setQuantity ( self : LibLevelGen . Entity , quantity : number ): LibLevelGen . Entity Set quantity (itemStack.quantity field) Parameters : Name Type Description self LibLevelGen.Entity The entity quantity number The quantity amount to set Returns : LibLevelGen.Entity","title":"LibLevelGen.Entity.setQuantity"},{"location":"modules/Entity.lua/#liblevelgenentitygiveitem","text":"giveItem ( self : LibLevelGen . Entity , item : string | LibLevelGen . Entity ): LibLevelGen . Entity Add an item to entity's inventory. Parameters : Name Type Description self LibLevelGen.Entity The entity item string | LibLevelGen.Entity Entity type or an existing entity to add to the inventory. Returns : LibLevelGen.Entity","title":"LibLevelGen.Entity.giveItem"},{"location":"modules/Entity.lua/#liblevelgenentitygetorcreateattribute","text":"getOrCreateAttribute ( self : LibLevelGen . Entity , component : string , field : string ): LibLevelGen . Entity Get an attribute of the entity. If it doesn't exist, it gets created and added (with no value specified) Parameters : Name Type Description self LibLevelGen.Entity The entity component string Component name field string Field name in the given component Returns : LibLevelGen.Entity","title":"LibLevelGen.Entity.getOrCreateAttribute"},{"location":"modules/Entity.lua/#liblevelgenentitystoreitem","text":"storeItem ( self : LibLevelGen . Entity , item : string ): LibLevelGen . Entity Add an item to entity's storage. Parameters : Name Type Description self LibLevelGen.Entity The entity item string Item entity type Returns : LibLevelGen.Entity","title":"LibLevelGen.Entity.storeItem"},{"location":"modules/ErrorLevel.lua/","text":"ErrorLevel.lua \u00b6 Functions \u00b6 errorLevel.generate \u00b6 errorLevel . generate ( parameters : LibLevelGen . LevelGenerationEventParameters ): void Generates a simple placeholder level. Parameters : Name Type Description parameters LibLevelGen.LevelGenerationEventParameters The parameters from the level generation event","title":"ErrorLevel.lua"},{"location":"modules/ErrorLevel.lua/#errorlevellua","text":"","title":"ErrorLevel.lua"},{"location":"modules/ErrorLevel.lua/#functions","text":"","title":"Functions"},{"location":"modules/ErrorLevel.lua/#errorlevelgenerate","text":"errorLevel . generate ( parameters : LibLevelGen . LevelGenerationEventParameters ): void Generates a simple placeholder level. Parameters : Name Type Description parameters LibLevelGen.LevelGenerationEventParameters The parameters from the level generation event","title":"errorLevel.generate"},{"location":"modules/LevelSequence.lua/","text":"LevelSequence.lua \u00b6 Functions \u00b6 levelSequence.templateAllZones \u00b6 levelSequence . templateAllZones (): fun ( ev : Event . LevelSequenceUpdate ) Level sequence which ends every zone with a random boss (the boss generator is automatically invoked). Returns : fun(ev: Event.LevelSequenceUpdate) levelSequence.templateBasic \u00b6 levelSequence . templateBasic (): fun ( ev : Event . LevelSequenceUpdate ) Basic level sequence which simply has a given amount of levels (based on maxLevel in generator config). Returns : fun(ev: Event.LevelSequenceUpdate) Other \u00b6 levelSequence.BuiltinGenerators \u00b6 -- A collection of built-in generator IDs. levelSequence . BuiltinGenerators = { -- The default generator used by all-zones mode. NECROLEVEL = proceduralLevel . GENERATOR_TYPE , -- Generator used to generate boss floors. BOSS = bossLevel . GENERATOR_TYPE , -- Custom dungeon loader. CUSTOM_DUNGEON = dungeonLoader . GENERATOR_TYPE , -- Training level. TRAINING = trainingLevel . GENERATOR_TYPE , }","title":"LevelSequence.lua"},{"location":"modules/LevelSequence.lua/#levelsequencelua","text":"","title":"LevelSequence.lua"},{"location":"modules/LevelSequence.lua/#functions","text":"","title":"Functions"},{"location":"modules/LevelSequence.lua/#levelsequencetemplateallzones","text":"levelSequence . templateAllZones (): fun ( ev : Event . LevelSequenceUpdate ) Level sequence which ends every zone with a random boss (the boss generator is automatically invoked). Returns : fun(ev: Event.LevelSequenceUpdate)","title":"levelSequence.templateAllZones"},{"location":"modules/LevelSequence.lua/#levelsequencetemplatebasic","text":"levelSequence . templateBasic (): fun ( ev : Event . LevelSequenceUpdate ) Basic level sequence which simply has a given amount of levels (based on maxLevel in generator config). Returns : fun(ev: Event.LevelSequenceUpdate)","title":"levelSequence.templateBasic"},{"location":"modules/LevelSequence.lua/#other","text":"","title":"Other"},{"location":"modules/LevelSequence.lua/#levelsequencebuiltingenerators","text":"-- A collection of built-in generator IDs. levelSequence . BuiltinGenerators = { -- The default generator used by all-zones mode. NECROLEVEL = proceduralLevel . GENERATOR_TYPE , -- Generator used to generate boss floors. BOSS = bossLevel . GENERATOR_TYPE , -- Custom dungeon loader. CUSTOM_DUNGEON = dungeonLoader . GENERATOR_TYPE , -- Training level. TRAINING = trainingLevel . GENERATOR_TYPE , }","title":"levelSequence.BuiltinGenerators"},{"location":"modules/LibLevelGen.lua/","text":"LibLevelGen.lua \u00b6 Functions \u00b6 libLevelGen.new \u00b6 libLevelGen . new ( ev : LibLevelGen . LevelGenerationEventParameters ): LibLegelGen . Instance Creates a new libLevelGen generator instance. Parameters : Name Type Description ev LibLevelGen.LevelGenerationEventParameters Parameters from the level generation event Returns : LibLegelGen.Instance libLevelGen.registerGenerator \u00b6 libLevelGen . registerGenerator ( name : string , func : function , data ? : LibLevelGen . Config , modeData ? : GameSession . Mode . Data ): number , number , number Registers a new generator (it will appear in the extra modes menu). Returns IDs of the generator, regular and seeded game modes created. Parameters : Name Type Description name string Name of the generator func function The callback function that will be called to generate the level data? LibLevelGen.Config Generator configuration, fields can be left empty to provide default values. modeData? GameSession.Mode.Data Game mode data, fields can be left empty to provide default values. Returns : number,number,number Classes \u00b6 LibLevelGen.RunState \u00b6 RunState used by LibLevelGen levels, compatible with the vanilla runState format. Properties : Name Type Description libLevelGenDataInitialized boolean Whether the runState has been initialized with libLevelGen-specific fields. Used when transitioning from vanilla runState format. previousLevelMinibosses table List of minibosses from the previous level. secretShopLevels table<number,number> Level number to shop ID mapping of secret shop levels. seenItems table<string,number> Mapping of seen item counts. seenShrines number[] Seen shrine IDs shrineLevels table<number,number> Level number to shrine ID mapping of levels where shrines should spawn. shopkeeperDead boolean Whether the shopkeeper has been killed. shopkeeperGhostLevel number What level the shopkeeper ghost should spawn in (relative to start of the zone) shopkeeperGhostDepth number What depth the shopkeeper ghost should spawn in peaceRingActive boolean Whether the ring of peace is active warRingActive boolean Whether the ring of war is active warShrineActive boolean Whether the shrine of war is active bossShrineActive boolean Whether the boss shrine is active spaceShrineActive boolean Whether the space shrine is active lockedShopPlaced boolean Whether a locked shop has been placed in this run secretRockRoomPlaced boolean Whether a vault has been placed in this run urnPlaced boolean Whether an urn has been placed in this run LibLevelGen.Config \u00b6 Configuration that enables or disables various built-in features of libLevelGen. Properties : Name Type Description allowLevel1Shrine boolean Whether a shrine is allowed to spawn on 1-1 or not allowOldShrines boolean Whether shrines that have been disabled in the AMPLIFIED DLC can spawn disableEnemyUpgrades boolean Whether enemy upgrades (or downgrades) through ring of war/peace/shrines etc should be disabled zones number Amount of zones levelsPerZone number Amount of levels per zone maxLevel number Max level number placeSecretShops boolean Whether secret shops should be automatically placed placeShrines boolean Whether shrines should be automatically placed sequenceClb fun(ev:Event.LevelSequenceUpdate, cfg: LibLevelGen.Config) Function which will be used to generate level sequence data. LibLevelGen.Generator \u00b6 LibLevelGen generation data registered by LibLevelGen.registerGenerator . Properties : Name Type Description name string Name of the generator func function Callback function of the generator data LibLevelGen.Config Configuration of the generator LibLevelGen.LevelGenerationOptions extends LevelGenerator.Options \u00b6 Configuration of the currently generated level Properties : Name Type Description number integer 1-indexed sequential identifier of this level in the whole run. Preserved across sub-runs type LevelGenerator.Type Stores the string ID of the generator to use for this level modeID GameSession.Mode Stores the string ID of the game mode to use for this level isFinal? boolean If true, completing this level counts as a victory and ends the run isLoopFinal? boolean If true, completing this level counts as a victory for the current loop initialCharacters? table<integer,string> Maps initially present player IDs to chosen characters seed integer Specifies the seed to generate this level with runState RunState Stores the current run state table loopID integer 1-index loop counter, tracking how many sub-runs have been performed within this run overridePastLevels? Level.Data Overwrites all past levels to reduce memory usage primaryPlayerID? Player.ID Optionally designates a player as the in-turn host for the current session zone number Current zone number depth number Current depth number floor number Current floor number LibLevelGen.LevelGenerationEventParameters \u00b6 Data passed by level generation event Properties : Name Type Description callback function The function that should be called with the generated level data as the argument data LibLevelGen.LevelGenerationOptions Configuration of the current level failMaps number Amount of times the generator has failed to generate this level libLevelGenGeneratorData LibLevelGen.Config Configuration of the level generator runState LibLevelGen.RunState State of the current run LibLevelGen.MusicData \u00b6 Structure that specifies music for the level Properties : Name Type Description id string ID of the music set. Generally you want to set it to \"OST\" , unless you're registering custom music. type string For id = \"OST\" , it's either \"zone\" or \"boss\" . level number Level number of the music zone number Zone number of the music LibLegelGen.Instance \u00b6 Instance of a level generator, used to do basically everything as far as generating levels goes. Properties : Name Type Description rng LibLevelGen.Rng RNG instance used by this generator instance levelGeneratorData LibLevelGen.Config Configuration of the generator used runState LibLevelGen.RunState RunState segments LibLevelGen.Segment[] Array of segments in this instance seed number Seed of the entire run isFinal boolean Whether the current level is the last one currentSeed number Seed of this level singleChoiceID number no description level number Current level number zone number Current zone depth number Current depth floor number Current floor music LibLevelGen.MusicData Music data for the generated level tileset string Tileset name that's inherited by newly created segments levelsPerZone number Amount of levels per zone boss number Whether the current level is a boss level. If it's not, boss is set to 0; Otherwise it's the boss ID. callback function Callback to call with the generated level data Methods : LibLegelGen.Instance.getDepth \u00b6 getDepth ( self : LibLegelGen . Instance ): number Get current depth Parameters : Name Type Description self LibLegelGen.Instance The instance Returns : number LibLegelGen.Instance.getFloor \u00b6 getFloor ( self : LibLegelGen . Instance ): number Get current floor Parameters : Name Type Description self LibLegelGen.Instance The instance Returns : number LibLegelGen.Instance.setMusic \u00b6 setMusic ( self : LibLegelGen . Instance , music : LibLevelGen . MusicData ): void Set music for this level Parameters : Name Type Description self LibLegelGen.Instance the instance music LibLevelGen.MusicData Music data LibLegelGen.Instance.setTileset \u00b6 setTileset ( self : LibLegelGen . Instance , tilesetName : string ): void Set default tileset Parameters : Name Type Description self LibLegelGen.Instance The instance tilesetName string Tileset name LibLegelGen.Instance.rand \u00b6 rand ( self : LibLegelGen . Instance ): number Generate a random 32-bit integer number. Parameters : Name Type Description self LibLegelGen.Instance The instance Returns : number LibLegelGen.Instance.randFloatRange \u00b6 randFloatRange ( self : LibLegelGen . Instance , min : number , max : number ): number Generate a random float within the given range. Parameters : Name Type Description self LibLegelGen.Instance The instance min number Minimum value max number Maximum value Returns : number LibLegelGen.Instance.randIntRange \u00b6 randIntRange ( self : LibLegelGen . Instance , min : number , max : number ): number Generate a random integer within the given range. Parameters : Name Type Description self LibLegelGen.Instance The instance min number Minimum value (inclusive) max number Maximum value (not inclusive) Returns : number LibLegelGen.Instance.randChoice \u00b6 randChoice ( self : LibLegelGen . Instance , t : T [], remove ? : boolean ): T Choose a random element from the given table. Parameters : Name Type Description self LibLegelGen.Instance The instance t T[] Table to choose an element from remove? boolean Whether the chosen element should be removed from the table, defaults to false Returns : T LibLegelGen.Instance.randChoiceMany \u00b6 randChoiceMany ( self : LibLegelGen . Instance , choices : T [], n : number , remove ? : boolean ): T Choose n elements from the given table. Parameters : Name Type Description self LibLegelGen.Instance The instance choices T[] Table to choose elements from n number Number of elements to choose remove? boolean Whether the chosen elements should be removed from the table, defaults to false Returns : T LibLegelGen.Instance.randChance \u00b6 randChance ( self : LibLegelGen . Instance , probability : number ): boolean Randomly returns boolean based on given probability. Parameters : Name Type Description self LibLegelGen.Instance The instance probability number Value between 0.0 and 1.0 Returns : boolean LibLegelGen.Instance.randWeightedChoice \u00b6 randWeightedChoice ( self : LibLegelGen . Instance , chances : table < string , number > ): string Randomly choose a value from the weighted choice data. Parameters : Name Type Description self LibLegelGen.Instance The instance chances table<string,number> Mapping of values that can be chosen to their probability (does not have to add up to 1) Returns : string LibLegelGen.Instance.createSegment \u00b6 createSegment ( self : LibLegelGen . Instance ): LibLevelGen . Segment Creates a new segment. Parameters : Name Type Description self LibLegelGen.Instance The instance Returns : LibLevelGen.Segment LibLegelGen.Instance.finalize \u00b6 finalize ( self : LibLegelGen . Instance ): void Serialize the level and invoke the callback to load it. This should be the last thing your generator calls. Parameters : Name Type Description self LibLegelGen.Instance The instance","title":"LibLevelGen.lua"},{"location":"modules/LibLevelGen.lua/#liblevelgenlua","text":"","title":"LibLevelGen.lua"},{"location":"modules/LibLevelGen.lua/#functions","text":"","title":"Functions"},{"location":"modules/LibLevelGen.lua/#liblevelgennew","text":"libLevelGen . new ( ev : LibLevelGen . LevelGenerationEventParameters ): LibLegelGen . Instance Creates a new libLevelGen generator instance. Parameters : Name Type Description ev LibLevelGen.LevelGenerationEventParameters Parameters from the level generation event Returns : LibLegelGen.Instance","title":"libLevelGen.new"},{"location":"modules/LibLevelGen.lua/#liblevelgenregistergenerator","text":"libLevelGen . registerGenerator ( name : string , func : function , data ? : LibLevelGen . Config , modeData ? : GameSession . Mode . Data ): number , number , number Registers a new generator (it will appear in the extra modes menu). Returns IDs of the generator, regular and seeded game modes created. Parameters : Name Type Description name string Name of the generator func function The callback function that will be called to generate the level data? LibLevelGen.Config Generator configuration, fields can be left empty to provide default values. modeData? GameSession.Mode.Data Game mode data, fields can be left empty to provide default values. Returns : number,number,number","title":"libLevelGen.registerGenerator"},{"location":"modules/LibLevelGen.lua/#classes","text":"","title":"Classes"},{"location":"modules/LibLevelGen.lua/#liblevelgenrunstate","text":"RunState used by LibLevelGen levels, compatible with the vanilla runState format. Properties : Name Type Description libLevelGenDataInitialized boolean Whether the runState has been initialized with libLevelGen-specific fields. Used when transitioning from vanilla runState format. previousLevelMinibosses table List of minibosses from the previous level. secretShopLevels table<number,number> Level number to shop ID mapping of secret shop levels. seenItems table<string,number> Mapping of seen item counts. seenShrines number[] Seen shrine IDs shrineLevels table<number,number> Level number to shrine ID mapping of levels where shrines should spawn. shopkeeperDead boolean Whether the shopkeeper has been killed. shopkeeperGhostLevel number What level the shopkeeper ghost should spawn in (relative to start of the zone) shopkeeperGhostDepth number What depth the shopkeeper ghost should spawn in peaceRingActive boolean Whether the ring of peace is active warRingActive boolean Whether the ring of war is active warShrineActive boolean Whether the shrine of war is active bossShrineActive boolean Whether the boss shrine is active spaceShrineActive boolean Whether the space shrine is active lockedShopPlaced boolean Whether a locked shop has been placed in this run secretRockRoomPlaced boolean Whether a vault has been placed in this run urnPlaced boolean Whether an urn has been placed in this run","title":"LibLevelGen.RunState"},{"location":"modules/LibLevelGen.lua/#liblevelgenconfig","text":"Configuration that enables or disables various built-in features of libLevelGen. Properties : Name Type Description allowLevel1Shrine boolean Whether a shrine is allowed to spawn on 1-1 or not allowOldShrines boolean Whether shrines that have been disabled in the AMPLIFIED DLC can spawn disableEnemyUpgrades boolean Whether enemy upgrades (or downgrades) through ring of war/peace/shrines etc should be disabled zones number Amount of zones levelsPerZone number Amount of levels per zone maxLevel number Max level number placeSecretShops boolean Whether secret shops should be automatically placed placeShrines boolean Whether shrines should be automatically placed sequenceClb fun(ev:Event.LevelSequenceUpdate, cfg: LibLevelGen.Config) Function which will be used to generate level sequence data.","title":"LibLevelGen.Config"},{"location":"modules/LibLevelGen.lua/#liblevelgengenerator","text":"LibLevelGen generation data registered by LibLevelGen.registerGenerator . Properties : Name Type Description name string Name of the generator func function Callback function of the generator data LibLevelGen.Config Configuration of the generator","title":"LibLevelGen.Generator"},{"location":"modules/LibLevelGen.lua/#liblevelgenlevelgenerationoptions-extends-levelgeneratoroptions","text":"Configuration of the currently generated level Properties : Name Type Description number integer 1-indexed sequential identifier of this level in the whole run. Preserved across sub-runs type LevelGenerator.Type Stores the string ID of the generator to use for this level modeID GameSession.Mode Stores the string ID of the game mode to use for this level isFinal? boolean If true, completing this level counts as a victory and ends the run isLoopFinal? boolean If true, completing this level counts as a victory for the current loop initialCharacters? table<integer,string> Maps initially present player IDs to chosen characters seed integer Specifies the seed to generate this level with runState RunState Stores the current run state table loopID integer 1-index loop counter, tracking how many sub-runs have been performed within this run overridePastLevels? Level.Data Overwrites all past levels to reduce memory usage primaryPlayerID? Player.ID Optionally designates a player as the in-turn host for the current session zone number Current zone number depth number Current depth number floor number Current floor number","title":"LibLevelGen.LevelGenerationOptions extends LevelGenerator.Options"},{"location":"modules/LibLevelGen.lua/#liblevelgenlevelgenerationeventparameters","text":"Data passed by level generation event Properties : Name Type Description callback function The function that should be called with the generated level data as the argument data LibLevelGen.LevelGenerationOptions Configuration of the current level failMaps number Amount of times the generator has failed to generate this level libLevelGenGeneratorData LibLevelGen.Config Configuration of the level generator runState LibLevelGen.RunState State of the current run","title":"LibLevelGen.LevelGenerationEventParameters"},{"location":"modules/LibLevelGen.lua/#liblevelgenmusicdata","text":"Structure that specifies music for the level Properties : Name Type Description id string ID of the music set. Generally you want to set it to \"OST\" , unless you're registering custom music. type string For id = \"OST\" , it's either \"zone\" or \"boss\" . level number Level number of the music zone number Zone number of the music","title":"LibLevelGen.MusicData"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstance","text":"Instance of a level generator, used to do basically everything as far as generating levels goes. Properties : Name Type Description rng LibLevelGen.Rng RNG instance used by this generator instance levelGeneratorData LibLevelGen.Config Configuration of the generator used runState LibLevelGen.RunState RunState segments LibLevelGen.Segment[] Array of segments in this instance seed number Seed of the entire run isFinal boolean Whether the current level is the last one currentSeed number Seed of this level singleChoiceID number no description level number Current level number zone number Current zone depth number Current depth floor number Current floor music LibLevelGen.MusicData Music data for the generated level tileset string Tileset name that's inherited by newly created segments levelsPerZone number Amount of levels per zone boss number Whether the current level is a boss level. If it's not, boss is set to 0; Otherwise it's the boss ID. callback function Callback to call with the generated level data Methods :","title":"LibLegelGen.Instance"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancegetdepth","text":"getDepth ( self : LibLegelGen . Instance ): number Get current depth Parameters : Name Type Description self LibLegelGen.Instance The instance Returns : number","title":"LibLegelGen.Instance.getDepth"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancegetfloor","text":"getFloor ( self : LibLegelGen . Instance ): number Get current floor Parameters : Name Type Description self LibLegelGen.Instance The instance Returns : number","title":"LibLegelGen.Instance.getFloor"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancesetmusic","text":"setMusic ( self : LibLegelGen . Instance , music : LibLevelGen . MusicData ): void Set music for this level Parameters : Name Type Description self LibLegelGen.Instance the instance music LibLevelGen.MusicData Music data","title":"LibLegelGen.Instance.setMusic"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancesettileset","text":"setTileset ( self : LibLegelGen . Instance , tilesetName : string ): void Set default tileset Parameters : Name Type Description self LibLegelGen.Instance The instance tilesetName string Tileset name","title":"LibLegelGen.Instance.setTileset"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancerand","text":"rand ( self : LibLegelGen . Instance ): number Generate a random 32-bit integer number. Parameters : Name Type Description self LibLegelGen.Instance The instance Returns : number","title":"LibLegelGen.Instance.rand"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancerandfloatrange","text":"randFloatRange ( self : LibLegelGen . Instance , min : number , max : number ): number Generate a random float within the given range. Parameters : Name Type Description self LibLegelGen.Instance The instance min number Minimum value max number Maximum value Returns : number","title":"LibLegelGen.Instance.randFloatRange"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancerandintrange","text":"randIntRange ( self : LibLegelGen . Instance , min : number , max : number ): number Generate a random integer within the given range. Parameters : Name Type Description self LibLegelGen.Instance The instance min number Minimum value (inclusive) max number Maximum value (not inclusive) Returns : number","title":"LibLegelGen.Instance.randIntRange"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancerandchoice","text":"randChoice ( self : LibLegelGen . Instance , t : T [], remove ? : boolean ): T Choose a random element from the given table. Parameters : Name Type Description self LibLegelGen.Instance The instance t T[] Table to choose an element from remove? boolean Whether the chosen element should be removed from the table, defaults to false Returns : T","title":"LibLegelGen.Instance.randChoice"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancerandchoicemany","text":"randChoiceMany ( self : LibLegelGen . Instance , choices : T [], n : number , remove ? : boolean ): T Choose n elements from the given table. Parameters : Name Type Description self LibLegelGen.Instance The instance choices T[] Table to choose elements from n number Number of elements to choose remove? boolean Whether the chosen elements should be removed from the table, defaults to false Returns : T","title":"LibLegelGen.Instance.randChoiceMany"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancerandchance","text":"randChance ( self : LibLegelGen . Instance , probability : number ): boolean Randomly returns boolean based on given probability. Parameters : Name Type Description self LibLegelGen.Instance The instance probability number Value between 0.0 and 1.0 Returns : boolean","title":"LibLegelGen.Instance.randChance"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancerandweightedchoice","text":"randWeightedChoice ( self : LibLegelGen . Instance , chances : table < string , number > ): string Randomly choose a value from the weighted choice data. Parameters : Name Type Description self LibLegelGen.Instance The instance chances table<string,number> Mapping of values that can be chosen to their probability (does not have to add up to 1) Returns : string","title":"LibLegelGen.Instance.randWeightedChoice"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancecreatesegment","text":"createSegment ( self : LibLegelGen . Instance ): LibLevelGen . Segment Creates a new segment. Parameters : Name Type Description self LibLegelGen.Instance The instance Returns : LibLevelGen.Segment","title":"LibLegelGen.Instance.createSegment"},{"location":"modules/LibLevelGen.lua/#liblegelgeninstancefinalize","text":"finalize ( self : LibLegelGen . Instance ): void Serialize the level and invoke the callback to load it. This should be the last thing your generator calls. Parameters : Name Type Description self LibLegelGen.Instance The instance","title":"LibLegelGen.Instance.finalize"},{"location":"modules/Loot.lua/","text":"Loot.lua \u00b6 Functions \u00b6 loot.chestForItem \u00b6 loot . chestForItem ( itemType : string ): string Get chest entity type for a given entity type. Parameters : Name Type Description itemType string Item entity type. Returns : string loot.createChestWithItem \u00b6 loot . createChestWithItem ( instance : LibLegelGen . Instance , itemType : string , hidden : boolean , entityType ? : string , entityLevel ? : number ): LibLevelGen . Entity Creates a chest containing a given item type. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of generated level. itemType string Item type to put inside of the chest. hidden boolean Whether the chest is only revealed when next to it. entityType? string Optional chest entity type (defaults to chest color based on the item) entityLevel? number Optional chest entity level Returns : LibLevelGen.Entity loot.createChest \u00b6 loot . createChest ( instance : LibLegelGen . Instance , args ? : LibLevelGen . ChestChoiceArguments ): void Creates a chest containing random item. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of the generated level. args? LibLevelGen.ChestChoiceArguments Extra parameters for the chest. loot.createGold \u00b6 loot . createGold ( instance : LibLegelGen . Instance , amount : number ): LibLevelGen . Entity Create a gold entity. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of the generated level. amount number gold amount to create Returns : LibLevelGen.Entity loot.createUrn \u00b6 loot . createUrn ( instance : LibLegelGen . Instance ): LibLevelGen . Entity Create an urn entity. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of the generated level. Returns : LibLevelGen.Entity loot.createCrate \u00b6 loot . createCrate ( instance : LibLegelGen . Instance , crateTypeOverride ? : string , crateLevelOverride ? : number ): LibLevelGen . Entity Create a create entity. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of the generated level. crateTypeOverride? string Force the crate to be a specific entity type. crateLevelOverride? number Force the crate to have a specific level. Returns : LibLevelGen.Entity loot.placeChests \u00b6 loot . placeChests ( segment : LibLevelGen . Segment ): void Place remaining chests. Parameters : Name Type Description segment LibLevelGen.Segment Segment in which the remaining chests should be placed. loot.placeCrates \u00b6 loot . placeCrates ( segment : LibLevelGen . Segment ): void Place remaining crates. Parameters : Name Type Description segment LibLevelGen.Segment Segment in which the remaining crates should be placed. Classes \u00b6 LibLevelGen.ChestChoiceArguments extends ItemGeneration.ChoiceArguments \u00b6 Interface for defining arguments of loot.createChest . Properties : Name Type Description player? Entity Do not generate items that this player can\u2019t pick up (defaults to a random initial player) banMask? ItemBan.Flag Ban flag to check on the player for item generation, defaults to GENERATE_ITEM_POOL slot? string If non-nil, only generate items matching that slot requiredComponents? string[] Only generate items that have all of those components excludedComponents? string[] Only generate items that have none of those components itemPool? string Component name used to determine item weights (the component needs a weights field) chanceType? string Compatibility alias for itemPool (only works for built-in item pools) levelBonus? integer Generate items from higher tiers chanceFunction? fun(Entity):integer Sets item weights (when set, chanceType and levelBonus are ignored) seenCounts? table<string,integer> Acts as a counter for tracking item generation to prevent duplicates, defaults to global counter depletionLimit? integer Items seen that many time will not be generated, defaults to 8 transmutedItem? Entity The item being transmuted, if any default? string If no items match the requirements, this is returned instead usePendingItems? boolean Prioritizes pending single-zone items ignoreProgression? boolean Allow generating locked items in single-zone result? string Resulting item type (used internally by event.itemGenerate ) hidden? boolean Whether the chest starts visible or not chestType? string Chest entity type (defaults to chest color based on the item) chestLevel? number Chest entity type level","title":"Loot.lua"},{"location":"modules/Loot.lua/#lootlua","text":"","title":"Loot.lua"},{"location":"modules/Loot.lua/#functions","text":"","title":"Functions"},{"location":"modules/Loot.lua/#lootchestforitem","text":"loot . chestForItem ( itemType : string ): string Get chest entity type for a given entity type. Parameters : Name Type Description itemType string Item entity type. Returns : string","title":"loot.chestForItem"},{"location":"modules/Loot.lua/#lootcreatechestwithitem","text":"loot . createChestWithItem ( instance : LibLegelGen . Instance , itemType : string , hidden : boolean , entityType ? : string , entityLevel ? : number ): LibLevelGen . Entity Creates a chest containing a given item type. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of generated level. itemType string Item type to put inside of the chest. hidden boolean Whether the chest is only revealed when next to it. entityType? string Optional chest entity type (defaults to chest color based on the item) entityLevel? number Optional chest entity level Returns : LibLevelGen.Entity","title":"loot.createChestWithItem"},{"location":"modules/Loot.lua/#lootcreatechest","text":"loot . createChest ( instance : LibLegelGen . Instance , args ? : LibLevelGen . ChestChoiceArguments ): void Creates a chest containing random item. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of the generated level. args? LibLevelGen.ChestChoiceArguments Extra parameters for the chest.","title":"loot.createChest"},{"location":"modules/Loot.lua/#lootcreategold","text":"loot . createGold ( instance : LibLegelGen . Instance , amount : number ): LibLevelGen . Entity Create a gold entity. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of the generated level. amount number gold amount to create Returns : LibLevelGen.Entity","title":"loot.createGold"},{"location":"modules/Loot.lua/#lootcreateurn","text":"loot . createUrn ( instance : LibLegelGen . Instance ): LibLevelGen . Entity Create an urn entity. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of the generated level. Returns : LibLevelGen.Entity","title":"loot.createUrn"},{"location":"modules/Loot.lua/#lootcreatecrate","text":"loot . createCrate ( instance : LibLegelGen . Instance , crateTypeOverride ? : string , crateLevelOverride ? : number ): LibLevelGen . Entity Create a create entity. Parameters : Name Type Description instance LibLegelGen.Instance The LibLevelGen instance of the generated level. crateTypeOverride? string Force the crate to be a specific entity type. crateLevelOverride? number Force the crate to have a specific level. Returns : LibLevelGen.Entity","title":"loot.createCrate"},{"location":"modules/Loot.lua/#lootplacechests","text":"loot . placeChests ( segment : LibLevelGen . Segment ): void Place remaining chests. Parameters : Name Type Description segment LibLevelGen.Segment Segment in which the remaining chests should be placed.","title":"loot.placeChests"},{"location":"modules/Loot.lua/#lootplacecrates","text":"loot . placeCrates ( segment : LibLevelGen . Segment ): void Place remaining crates. Parameters : Name Type Description segment LibLevelGen.Segment Segment in which the remaining crates should be placed.","title":"loot.placeCrates"},{"location":"modules/Loot.lua/#classes","text":"","title":"Classes"},{"location":"modules/Loot.lua/#liblevelgenchestchoicearguments-extends-itemgenerationchoicearguments","text":"Interface for defining arguments of loot.createChest . Properties : Name Type Description player? Entity Do not generate items that this player can\u2019t pick up (defaults to a random initial player) banMask? ItemBan.Flag Ban flag to check on the player for item generation, defaults to GENERATE_ITEM_POOL slot? string If non-nil, only generate items matching that slot requiredComponents? string[] Only generate items that have all of those components excludedComponents? string[] Only generate items that have none of those components itemPool? string Component name used to determine item weights (the component needs a weights field) chanceType? string Compatibility alias for itemPool (only works for built-in item pools) levelBonus? integer Generate items from higher tiers chanceFunction? fun(Entity):integer Sets item weights (when set, chanceType and levelBonus are ignored) seenCounts? table<string,integer> Acts as a counter for tracking item generation to prevent duplicates, defaults to global counter depletionLimit? integer Items seen that many time will not be generated, defaults to 8 transmutedItem? Entity The item being transmuted, if any default? string If no items match the requirements, this is returned instead usePendingItems? boolean Prioritizes pending single-zone items ignoreProgression? boolean Allow generating locked items in single-zone result? string Resulting item type (used internally by event.itemGenerate ) hidden? boolean Whether the chest starts visible or not chestType? string Chest entity type (defaults to chest color based on the item) chestLevel? number Chest entity type level","title":"LibLevelGen.ChestChoiceArguments extends ItemGeneration.ChoiceArguments"},{"location":"modules/Rand.lua/","text":"Rand.lua \u00b6 Functions \u00b6 rand.new \u00b6 rand . new ( seed : number ): LibLevelGen . Rng Create a new random number generator instance. Parameters : Name Type Description seed number Initial seed Returns : LibLevelGen.Rng Classes \u00b6 LibLevelGen.Rng \u00b6 Helper class for generating random numbers given a starting seed. Methods : LibLevelGen.Rng.rand \u00b6 rand ( self : LibLevelGen . Rng ): number Generate a random 32-bit integer number. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance Returns : number LibLevelGen.Rng.randFloatRange \u00b6 randFloatRange ( self : LibLevelGen . Rng , min : number , max : number ): number Generate a random float within the given range. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance min number Minimum value max number Maximum value Returns : number LibLevelGen.Rng.randIntRange \u00b6 randIntRange ( self : LibLevelGen . Rng , min : number , max : number ): number Generate a random integer within the given range. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance min number Minimum value (inclusive) max number Maximum value (not inclusive) Returns : number LibLevelGen.Rng.randChoice \u00b6 randChoice ( self : LibLevelGen . Rng , t : T [], remove ? : boolean ): T Choose a random element from the given table. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance t T[] Elements to choose from remove? boolean If true, element will be removed from the original table. Returns : T LibLevelGen.Rng.randChoiceMany \u00b6 randChoiceMany ( self : LibLevelGen . Rng , choices : T [], n : number , remove : boolean ): T Choose a n elements from the given table. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance choices T[] Elements to choose from n number Number of elements to choose remove boolean If true, element will be removed from the original table. Returns : T LibLevelGen.Rng.randChance \u00b6 randChance ( self : LibLevelGen . Rng , probability : number ): boolean Randomly returns boolean based on given probability. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance probability number Value between 0.0 and 1.0 Returns : boolean LibLevelGen.Rng.randWeightedChoice \u00b6 randWeightedChoice ( self : LibLevelGen . Rng , chances : table < string , number > ): string Randomly choose a value from the weighted choice data. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance chances table<string,number> Mapping of values that can be chosen to their probability (does not have to add up to 1) Returns : string","title":"Rand.lua"},{"location":"modules/Rand.lua/#randlua","text":"","title":"Rand.lua"},{"location":"modules/Rand.lua/#functions","text":"","title":"Functions"},{"location":"modules/Rand.lua/#randnew","text":"rand . new ( seed : number ): LibLevelGen . Rng Create a new random number generator instance. Parameters : Name Type Description seed number Initial seed Returns : LibLevelGen.Rng","title":"rand.new"},{"location":"modules/Rand.lua/#classes","text":"","title":"Classes"},{"location":"modules/Rand.lua/#liblevelgenrng","text":"Helper class for generating random numbers given a starting seed. Methods :","title":"LibLevelGen.Rng"},{"location":"modules/Rand.lua/#liblevelgenrngrand","text":"rand ( self : LibLevelGen . Rng ): number Generate a random 32-bit integer number. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance Returns : number","title":"LibLevelGen.Rng.rand"},{"location":"modules/Rand.lua/#liblevelgenrngrandfloatrange","text":"randFloatRange ( self : LibLevelGen . Rng , min : number , max : number ): number Generate a random float within the given range. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance min number Minimum value max number Maximum value Returns : number","title":"LibLevelGen.Rng.randFloatRange"},{"location":"modules/Rand.lua/#liblevelgenrngrandintrange","text":"randIntRange ( self : LibLevelGen . Rng , min : number , max : number ): number Generate a random integer within the given range. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance min number Minimum value (inclusive) max number Maximum value (not inclusive) Returns : number","title":"LibLevelGen.Rng.randIntRange"},{"location":"modules/Rand.lua/#liblevelgenrngrandchoice","text":"randChoice ( self : LibLevelGen . Rng , t : T [], remove ? : boolean ): T Choose a random element from the given table. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance t T[] Elements to choose from remove? boolean If true, element will be removed from the original table. Returns : T","title":"LibLevelGen.Rng.randChoice"},{"location":"modules/Rand.lua/#liblevelgenrngrandchoicemany","text":"randChoiceMany ( self : LibLevelGen . Rng , choices : T [], n : number , remove : boolean ): T Choose a n elements from the given table. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance choices T[] Elements to choose from n number Number of elements to choose remove boolean If true, element will be removed from the original table. Returns : T","title":"LibLevelGen.Rng.randChoiceMany"},{"location":"modules/Rand.lua/#liblevelgenrngrandchance","text":"randChance ( self : LibLevelGen . Rng , probability : number ): boolean Randomly returns boolean based on given probability. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance probability number Value between 0.0 and 1.0 Returns : boolean","title":"LibLevelGen.Rng.randChance"},{"location":"modules/Rand.lua/#liblevelgenrngrandweightedchoice","text":"randWeightedChoice ( self : LibLevelGen . Rng , chances : table < string , number > ): string Randomly choose a value from the weighted choice data. Parameters : Name Type Description self LibLevelGen.Rng The RNG instance chances table<string,number> Mapping of values that can be chosen to their probability (does not have to add up to 1) Returns : string","title":"LibLevelGen.Rng.randWeightedChoice"},{"location":"modules/Room.lua/","text":"Room.lua \u00b6 Functions \u00b6 room.new \u00b6 room . new ( instance : LibLegelGen . Instance , segment : LibLevelGen . Segment , x : number , y : number , w : number , h : number , flags : number ): LibLevelGen . Room Create a new room within the segment. Parameters : Name Type Description instance LibLegelGen.Instance The instance. segment LibLevelGen.Segment The segment. x number X coordinate of room's top-left corner. y number Y coordinate of room's top-left corner. w number Room width. h number Room height. flags number Room flags. Returns : LibLevelGen.Room Classes \u00b6 LibLevelGen.TileRequirements \u00b6 Interface used for selecting tiles based on the given requirement. Fields of the Tribool type can be nil , true or false . When a Tribool is nil the condition is not checked, and if it's a boolean then the condition check result must match the value specified. Properties : Name Type Description isFloor TriBool Whether the tile is a floor. isWall TriBool Whether the tile is a wall. levelExit TriBool Whether the tile is the level exit. hasWallTorch TriBool Whether the tile has a wall torch. hasEntity TriBool Whether the tile has an entity. tileType string | nil Required tile type string name. nearFloor TriBool Whether the tile is near a floor tile, checked within this room only. nearWall TriBool Whether the tile is near a wall tile, checked within this room only. nearBorder TriBool Whether the tile is near the room border. filter fun(room: LibLevelGen.Room, tile: LibLevelGen.Tile) | nil Filter function, if it returns true the condition check passes. notCollision number | nil Collision (from necro.game.tile.Collision ) bits which must all NOT be set. collision number | nil Collision (from necro.game.tile.Collision ) bits which must all be set. rect LibLevelGen.Rect | nil Rect the tile must be in. notRect LibLevelGen.Rect | nil Rect the tile must NOT be in. wire TriBool Whether the tile has an electric wile. info table | nil Require the tile to have a specific tileInfo (from necro.game.tile.TileTypes ) entrance TriBool Whether the tile is the entrance to the room (directly next to the corridor). adjacentEntrance TriBool Whether the tile is adjacent to the entrance. directlyAdjacentEntrance TriBool Whether the tile is adjacent to the entrance, but not diagonally. noWallTallSprite TriBool Whether the tile below the checked tile is a wall. LibLevelGen.Tile \u00b6 Object representing a single tile. This will be moved to a separate module in the future. Properties : Name Type Description tileset string Tileset the tile uses. type string Tile type the tile uses. info table TileInfo of the tile (from necro.game.tile.TileTypes ). wire integer The wire connectivity bitmask. hasEntity boolean Whether the tile has an entity. entities LibLevelGen.Entity[] List of entities on this tile. hasWallTorch boolean Whether the tile has a wall torch. x number X coordinate of the tile in the room. y number Y coordinate of the tile in the room. rx number X coordinate of the tile in the segment. ry number Y coordinate of the tile in the segment. adjacentEntrance boolean Whether the tile is adjacent to an entrance. directlyAdjacentEntrance boolean Whether the tile is adjacent to an entrance, but not diagonally. isEntrance boolean Whether the tile is the entrance to the room (directly next to the corridor). room LibLevelGen.Room Room this tile belongs to. instance LibLegelGen.Instance Instance this tile belongs to. Methods : LibLevelGen.Tile.convert \u00b6 convert ( self : LibLevelGen . Tile , tileType : string ): void Convert the tile to a different type. Parameters : Name Type Description self LibLevelGen.Tile The tile tileType string TileType to convert to. LibLevelGen.Tile.setIsEntrance \u00b6 setIsEntrance ( self : LibLevelGen . Tile ): void Set the isEntrance flag on the tile and adjacentEntrance flags on nearby tiles. Parameters : Name Type Description self LibLevelGen.Tile The tile LibLevelGen.Tile.placeEntity \u00b6 placeEntity ( self : LibLevelGen . Tile , entityOrType : string | LibLevelGen . Entity , level ? : number ): LibLevelGen . Entity Place entity of given type and level on the tile. Parameters : Name Type Description self LibLevelGen.Tile The tile. entityOrType string | LibLevelGen.Entity Entity type or existing entity. level? number Entity level, ignored if existing entity is passed in the previous argument. Returns : LibLevelGen.Entity LibLevelGen.Tile.meetsRequirements \u00b6 meetsRequirements ( self : LibLevelGen . Tile , requirements : LibLevelGen . TileRequirements ): void Check if the tile meets specified requirements. Parameters : Name Type Description self LibLevelGen.Tile The tile. requirements LibLevelGen.TileRequirements Requirements the tile has to meet. LibLevelGen.Tile.tileBelowIsWall \u00b6 tileBelowIsWall ( self : LibLevelGen . Tile ): void Whether a wall tile or the room border is below this tile. Parameters : Name Type Description self LibLevelGen.Tile The tile. LibLevelGen.Tile.inRect \u00b6 inRect ( self : LibLevelGen . Tile , rect : LibLevelGen . Rect ): void Check if the tile is within a given rect in the room. Parameters : Name Type Description self LibLevelGen.Tile The tile. rect LibLevelGen.Rect Rect to check against. LibLevelGen.RoomLinkData \u00b6 Data which represents where a room connects to other rooms. Properties : Name Type Description x number Top-left X coordinate of the connection. y number Top-left Y coordinate of the connection. centerX number X center of the connection. centerY number Y center of the connection. axis number LibLevelGen.Axis size number How long the connection is, it's either width or height, depending on the axis. room LibLevelGen.Room The room that the link leads to. LibLevelGen.RoomLinks \u00b6 Object containing room links for every side of the room. Properties : Name Type Description top LibLevelGen.RoomLinkData[] Link data of the top side of the room. bottom LibLevelGen.RoomLinkData[] Link data of the bottom side of the room. left LibLevelGen.RoomLinkData[] Link data of the left side of the room. right LibLevelGen.RoomLinkData[] Link data of the right side of the room. LibLevelGen.Point \u00b6 Simple point interface. Properties : Name Type Description x number x y number y LibLevelGen.Room \u00b6 Object representing a room. Properties : Name Type Description x number X coordinate of the room's top left corner within the segment. y number Y coordinate of the room's top left corner within the segment. w number Width of the room. h number Height of the room. flags number Room flags (from room.Flag ). links LibLevelGen.RoomLinkData[] Information about the rooms adjacent to this room and where exactly the entrances are. padding LibLevelGen.PaddingData | nil Padding override to use instead of the segment-defined one. tiles LibLevelGen.Tile[] Array of tiles in this room. exit LibLevelGen.Point | nil Coordinates of exit stairs within this room (if they exist). instance LibLegelGen.Instance Instance this room belongs to. segment LibLevelGen.Segment Segment this table belongs to. userData table Table where you can put whatever you want safely. Methods : LibLevelGen.Room.setFlags \u00b6 setFlags ( self : LibLevelGen . Room , newFlags : number ): void Adds new flags on top of existing flags. Parameters : Name Type Description self LibLevelGen.Room The room. newFlags number The new flags. LibLevelGen.Room.clearFlags \u00b6 clearFlags ( self : LibLevelGen . Room , flagsToClear : number ): void Removes the given flags. Parameters : Name Type Description self LibLevelGen.Room The room. flagsToClear number Flags to remove. LibLevelGen.Room.maskFlags \u00b6 maskFlags ( self : LibLevelGen . Room , flags : number ): void Removes all flags apart from the given ones. Parameters : Name Type Description self LibLevelGen.Room the room. flags number Flags to use as a mask. LibLevelGen.Room.checkFlags \u00b6 checkFlags ( self : LibLevelGen . Room , flags : number ): void Checks if the given flags are set. Parameters : Name Type Description self LibLevelGen.Room The room. flags number Flags to check. LibLevelGen.Room.setPaddingTileOverride \u00b6 setPaddingTileOverride ( self : LibLevelGen . Room , data : LibLevelGen . PaddingData ): void Set the padding that will be used instead of the one specified by the segment. Parameters : Name Type Description self LibLevelGen.Room The room. data LibLevelGen.PaddingData Padding definition object. LibLevelGen.Room.getBounds \u00b6 getBounds ( self : LibLevelGen . Room ): number [] Get bounds of the room (in table {x, y, w, h} ). Parameters : Name Type Description self LibLevelGen.Room The room. Returns : number[] LibLevelGen.Room.getRect \u00b6 getRect ( self : LibLevelGen . Room ): LibLevelGen . Rect Get rect of the room. Parameters : Name Type Description self LibLevelGen.Room The room. Returns : LibLevelGen.Rect LibLevelGen.Room.setTile \u00b6 setTile ( self : LibLevelGen . Room , x : number , y : number , tileType : string , tileset ? : string ): void Set tile on the given coordinates. If tileset is not specified, the default one of the segment is used. Parameters : Name Type Description self LibLevelGen.Room The room. x number X coordinates of the tile. y number Y coordinates of the tile. tileType string The tile type tileset? string The tileset, if not specified defaults to the tileset of the segment. LibLevelGen.Room.getTile \u00b6 getTile ( self : LibLevelGen . Room , x : number , y : number ): LibLevelGen . Tile Get tile on given coordinates Parameters : Name Type Description self LibLevelGen.Room The room. x number X coordinates of the tile. y number Y coordinates of the tile. Returns : LibLevelGen.Tile LibLevelGen.Room.deleteTile \u00b6 deleteTile ( self : LibLevelGen . Room , x : number , y : number ): void Delete the given tile (set it to Void pseudotile) Parameters : Name Type Description self LibLevelGen.Room The room. x number X coordinates of the tile. y number Y coordinates of the tile. LibLevelGen.Room.isTileNearWall \u00b6 isTileNearWall ( self : LibLevelGen . Room , tile : LibLevelGen . Tile ): boolean Checks if the given tile (assumed to be within this room) is near a wall tile. Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile The tile to check. Returns : boolean LibLevelGen.Room.isTileNearFloor \u00b6 isTileNearFloor ( self : LibLevelGen . Room , tile : LibLevelGen . Tile ): boolean Checks if the given tile (assumed to be within this room) is near a floor tile. Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile The tile to check. Returns : boolean LibLevelGen.Room.isTileNearBorder \u00b6 isTileNearBorder ( self : LibLevelGen . Room , tile : LibLevelGen . Tile ): boolean Checks if the given tile (assumed to be within this room) is near the edge of the room. Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile The tile to check. Returns : boolean LibLevelGen.Room.fill \u00b6 fill ( self : LibLevelGen . Room , parameters : LibLevelGen . RoomFillParameters | string ): void Fill the room. Parameters : Name Type Description self LibLevelGen.Room The room. parameters LibLevelGen.RoomFillParameters | string Either the RoomFillParameters object or simply the tile type string. LibLevelGen.Room.border \u00b6 border ( self : LibLevelGen . Room , parameters : LibLevelGen . RoomBorderParameters | string ): void Create a border around the room. Parameters : Name Type Description self LibLevelGen.Room The room. parameters LibLevelGen.RoomBorderParameters | string Either a RoomBorderParameters specifying the border details, or simply a string tile type to create a basic border. LibLevelGen.Room.selectTiles \u00b6 selectTiles ( self : LibLevelGen . Room , requirements : LibLevelGen . TileRequirements ): LibLevelGen . Tile [] Returns all tiles that meet the requirements. Parameters : Name Type Description self LibLevelGen.Room The room. requirements LibLevelGen.TileRequirements Tile requirements to check against. Returns : LibLevelGen.Tile[] LibLevelGen.Room.chooseRandomTile \u00b6 chooseRandomTile ( self : LibLevelGen . Room , requirements : LibLevelGen . TileRequirements ): LibLevelGen . Tile Choose a random tile out of ones that meet requirements Parameters : Name Type Description self LibLevelGen.Room The room. requirements LibLevelGen.TileRequirements Tile requirements to check against. Returns : LibLevelGen.Tile LibLevelGen.Room.chooseRandomTiles \u00b6 chooseRandomTiles ( self : LibLevelGen . Room , num : number , requirements : LibLevelGen . TileRequirements ): LibLevelGen . Tile [] Choose multiple tiles out of ones that meet requirements. Parameters : Name Type Description self LibLevelGen.Room The room. num number Amount of tiles to choose. requirements LibLevelGen.TileRequirements Tile requirements to check against. Returns : LibLevelGen.Tile[] LibLevelGen.Room.placeWallTorch \u00b6 placeWallTorch ( self : LibLevelGen . Room , tile : LibLevelGen . Tile , type ? : string ): void Place a wall torch on the given tile. Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile Tile to place the torch on. type? string Optional walltorch entity type override. LibLevelGen.Room.placeWallTorches \u00b6 placeWallTorches ( self : LibLevelGen . Room , num : number , type ? : string ): void Place given amount of wall torches randomly on elligible tiles. Parameters : Name Type Description self LibLevelGen.Room The room. num number Amount of weall torches to place. type? string Optional walltorch entity type override. LibLevelGen.Room.placeEntity \u00b6 placeEntity ( self : LibLevelGen . Room , tile : LibLevelGen . Tile , entityOrType : string | LibLevelGen . Entity , level ? : number ): void Place entity on the given tile (wrapper around tile:placeEntity that checks if tile is not nil) Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile The tile to place the entity on. entityOrType string | LibLevelGen.Entity Existing entity or an entity type to spawn. level? number Optional entity level if passing a string entity type. LibLevelGen.Room.placeEntityAt \u00b6 placeEntityAt ( self : LibLevelGen . Room , x : number , y : number , entityOrType : string | LibLevelGen . Entity , level ? : number ): void Place entity on a tile on given coordinates. Parameters : Name Type Description self LibLevelGen.Room The room. x number X coordinate. y number Y coordinate. entityOrType string | LibLevelGen.Entity Existing entity or an entity type to spawn. level? number Optional entity level if passing a string entity type. LibLevelGen.Room.placeEntityRand \u00b6 placeEntityRand ( self : LibLevelGen . Room , requirements : LibLevelGen . TileRequirements , entityOrType : string | LibLevelGen . Entity , level ? : number ): void Place entity on a random tile that meets requrements. Parameters : Name Type Description self LibLevelGen.Room The room. requirements LibLevelGen.TileRequirements Requirements used to select the tile. entityOrType string | LibLevelGen.Entity Existing entity or an entity type to spawn. level? number Optional entity level if passing a string entity type. LibLevelGen.Room.placeWire \u00b6 placeWire ( self : LibLevelGen . Room , tile : LibLevelGen . Tile , connectivity : number ): void Place wire on the given tile. Parameters : Name Type Description self LibLevelGen.Room The room tile LibLevelGen.Tile Tile to place the wire on. connectivity number Unused, reserved. LibLevelGen.Room.makeExit \u00b6 makeExit ( self : LibLevelGen . Room , minibosses : table ): void Turn the room into an exit room - set appropriate flags, place the exit stairs and the miniboss. Parameters : Name Type Description self LibLevelGen.Room The room. minibosses table List of possible minibosses, in format: { {\"type1\", level1}, {\"type2\", level2}, ... } LibLevelGen.Room.placeExit \u00b6 placeExit ( self : LibLevelGen . Room ): void Place exit somewhere in the room. Parameters : Name Type Description self LibLevelGen.Room The room. LibLevelGen.Room.placeMiniboss \u00b6 placeMiniboss ( self : LibLevelGen . Room , minibosses : table ): void Place a miniboss in the room (assumes that the room is an exit room). Parameters : Name Type Description self LibLevelGen.Room The room. minibosses table In format {{\"type\", level}, ...} . LibLevelGen.Room.randomlyConvertTiles \u00b6 randomlyConvertTiles ( self : LibLevelGen . Room , sourceType : string , targetType : string , ratio : number ): void Randomly convert tiles from sourceType to targetType, chance of conversion happening is ratio. Parameters : Name Type Description self LibLevelGen.Room The room. sourceType string Tile type to convert from. targetType string Tile type to convert to. ratio number Chance of the conversion happening, a float between 0.0 and 1.0. LibLevelGen.Room.convertTiles \u00b6 convertTiles ( self : LibLevelGen . Room , sourceType : string , targetType : string ): void Convert all tiles from source type to target type, preserving their tileset. Parameters : Name Type Description self LibLevelGen.Room The room. sourceType string Tile type to convert from. targetType string Tile type to convert to. LibLevelGen.Room.spreadTile \u00b6 spreadTile ( self : LibLevelGen . Room , targetType : string , requirements : LibLevelGen . TileRequirements , minConvert : number , maxConvert : number , initialTile ? : LibLevelGen . Tile ): void Choose 1 tile that meets requirement and convert it and other nearby tiles to target type. Parameters : Name Type Description self LibLevelGen.Room The room. targetType string Tiletype to convert the tiles to. requirements LibLevelGen.TileRequirements The tile requirements used to pick the initial tile and the subsequent tiles. minConvert number Minimum number of tiles to convert. maxConvert number Maximum number of tiles to convert. initialTile? LibLevelGen.Tile Can be used to specify initial tile, instead of choosing it randomly. LibLevelGen.Room.makeShop \u00b6 makeShop ( self : LibLevelGen . Room , locked ? : boolean , force ? : boolean ): void Make the room a shop. TODO: move into a separate module Parameters : Name Type Description self LibLevelGen.Room The room locked? boolean Whether the shop should be a locked shop force? boolean Whether to force shopkeeper and items to spawn even if the shopkeeper killed flag is set in runState. LibLevelGen.RoomFillParameters extends LibLevelGen.TileData \u00b6 no description Properties : Name Type Description tileset string no description type string no description rect LibLevelGen.Rect | nil no description LibLevelGen.RoomBorderSideCount \u00b6 no description Properties : Name Type Description top number Top tile count. bottom number Bottom tile count. left number Left tile count. right number Right tile count. LibLevelGen.RoomBorderParameters extends LibLevelGen.TileData \u00b6 Object used to specify room border details. Properties : Name Type Description tileset string no description type string no description rect LibLevelGen.Rect The rect around which to place the border. sides LibLevelGen.RoomBorderSideCount Definition of wall count on each side. Enums \u00b6 room.Axis \u00b6 Used to determine whether a room was generated vertically or horizontally. Entries : VERTICAL HORIZONTAL room.Flag \u00b6 Flags which determine the properties of the room Entries : NONE ALLOW_ENEMY ALLOW_CHEST ALLOW_CRATE ALLOW_TRAP ALLOW_TRAVELRUNE ALLOW_SHRINE ALLOW_TORCH ALLOW_TILE_CONVERSION ALLOW_SECRET_FILL EXIT STARTING room.Type \u00b6 Helper enum containing common room.Flag bitmasks. Entries : REGULAR STARTING EXIT CORRIDOR SECRET SHOP SECRET_SHOP OTHER Other \u00b6 room.Direction \u00b6 room . Direction = action . Direction -- From necro.game.system.Action room.DirectionVector \u00b6 room . DirectionVector = { [ room . Direction . LEFT ] = { - 1 , 0 }, [ room . Direction . RIGHT ] = { 1 , 0 }, [ room . Direction . UP ] = { 0 , - 1 }, [ room . Direction . DOWN ] = { 0 , 1 } } Tribool alias \u00b6 --- @alias TriBool boolean | nil","title":"Room.lua"},{"location":"modules/Room.lua/#roomlua","text":"","title":"Room.lua"},{"location":"modules/Room.lua/#functions","text":"","title":"Functions"},{"location":"modules/Room.lua/#roomnew","text":"room . new ( instance : LibLegelGen . Instance , segment : LibLevelGen . Segment , x : number , y : number , w : number , h : number , flags : number ): LibLevelGen . Room Create a new room within the segment. Parameters : Name Type Description instance LibLegelGen.Instance The instance. segment LibLevelGen.Segment The segment. x number X coordinate of room's top-left corner. y number Y coordinate of room's top-left corner. w number Room width. h number Room height. flags number Room flags. Returns : LibLevelGen.Room","title":"room.new"},{"location":"modules/Room.lua/#classes","text":"","title":"Classes"},{"location":"modules/Room.lua/#liblevelgentilerequirements","text":"Interface used for selecting tiles based on the given requirement. Fields of the Tribool type can be nil , true or false . When a Tribool is nil the condition is not checked, and if it's a boolean then the condition check result must match the value specified. Properties : Name Type Description isFloor TriBool Whether the tile is a floor. isWall TriBool Whether the tile is a wall. levelExit TriBool Whether the tile is the level exit. hasWallTorch TriBool Whether the tile has a wall torch. hasEntity TriBool Whether the tile has an entity. tileType string | nil Required tile type string name. nearFloor TriBool Whether the tile is near a floor tile, checked within this room only. nearWall TriBool Whether the tile is near a wall tile, checked within this room only. nearBorder TriBool Whether the tile is near the room border. filter fun(room: LibLevelGen.Room, tile: LibLevelGen.Tile) | nil Filter function, if it returns true the condition check passes. notCollision number | nil Collision (from necro.game.tile.Collision ) bits which must all NOT be set. collision number | nil Collision (from necro.game.tile.Collision ) bits which must all be set. rect LibLevelGen.Rect | nil Rect the tile must be in. notRect LibLevelGen.Rect | nil Rect the tile must NOT be in. wire TriBool Whether the tile has an electric wile. info table | nil Require the tile to have a specific tileInfo (from necro.game.tile.TileTypes ) entrance TriBool Whether the tile is the entrance to the room (directly next to the corridor). adjacentEntrance TriBool Whether the tile is adjacent to the entrance. directlyAdjacentEntrance TriBool Whether the tile is adjacent to the entrance, but not diagonally. noWallTallSprite TriBool Whether the tile below the checked tile is a wall.","title":"LibLevelGen.TileRequirements"},{"location":"modules/Room.lua/#liblevelgentile","text":"Object representing a single tile. This will be moved to a separate module in the future. Properties : Name Type Description tileset string Tileset the tile uses. type string Tile type the tile uses. info table TileInfo of the tile (from necro.game.tile.TileTypes ). wire integer The wire connectivity bitmask. hasEntity boolean Whether the tile has an entity. entities LibLevelGen.Entity[] List of entities on this tile. hasWallTorch boolean Whether the tile has a wall torch. x number X coordinate of the tile in the room. y number Y coordinate of the tile in the room. rx number X coordinate of the tile in the segment. ry number Y coordinate of the tile in the segment. adjacentEntrance boolean Whether the tile is adjacent to an entrance. directlyAdjacentEntrance boolean Whether the tile is adjacent to an entrance, but not diagonally. isEntrance boolean Whether the tile is the entrance to the room (directly next to the corridor). room LibLevelGen.Room Room this tile belongs to. instance LibLegelGen.Instance Instance this tile belongs to. Methods :","title":"LibLevelGen.Tile"},{"location":"modules/Room.lua/#liblevelgentileconvert","text":"convert ( self : LibLevelGen . Tile , tileType : string ): void Convert the tile to a different type. Parameters : Name Type Description self LibLevelGen.Tile The tile tileType string TileType to convert to.","title":"LibLevelGen.Tile.convert"},{"location":"modules/Room.lua/#liblevelgentilesetisentrance","text":"setIsEntrance ( self : LibLevelGen . Tile ): void Set the isEntrance flag on the tile and adjacentEntrance flags on nearby tiles. Parameters : Name Type Description self LibLevelGen.Tile The tile","title":"LibLevelGen.Tile.setIsEntrance"},{"location":"modules/Room.lua/#liblevelgentileplaceentity","text":"placeEntity ( self : LibLevelGen . Tile , entityOrType : string | LibLevelGen . Entity , level ? : number ): LibLevelGen . Entity Place entity of given type and level on the tile. Parameters : Name Type Description self LibLevelGen.Tile The tile. entityOrType string | LibLevelGen.Entity Entity type or existing entity. level? number Entity level, ignored if existing entity is passed in the previous argument. Returns : LibLevelGen.Entity","title":"LibLevelGen.Tile.placeEntity"},{"location":"modules/Room.lua/#liblevelgentilemeetsrequirements","text":"meetsRequirements ( self : LibLevelGen . Tile , requirements : LibLevelGen . TileRequirements ): void Check if the tile meets specified requirements. Parameters : Name Type Description self LibLevelGen.Tile The tile. requirements LibLevelGen.TileRequirements Requirements the tile has to meet.","title":"LibLevelGen.Tile.meetsRequirements"},{"location":"modules/Room.lua/#liblevelgentiletilebelowiswall","text":"tileBelowIsWall ( self : LibLevelGen . Tile ): void Whether a wall tile or the room border is below this tile. Parameters : Name Type Description self LibLevelGen.Tile The tile.","title":"LibLevelGen.Tile.tileBelowIsWall"},{"location":"modules/Room.lua/#liblevelgentileinrect","text":"inRect ( self : LibLevelGen . Tile , rect : LibLevelGen . Rect ): void Check if the tile is within a given rect in the room. Parameters : Name Type Description self LibLevelGen.Tile The tile. rect LibLevelGen.Rect Rect to check against.","title":"LibLevelGen.Tile.inRect"},{"location":"modules/Room.lua/#liblevelgenroomlinkdata","text":"Data which represents where a room connects to other rooms. Properties : Name Type Description x number Top-left X coordinate of the connection. y number Top-left Y coordinate of the connection. centerX number X center of the connection. centerY number Y center of the connection. axis number LibLevelGen.Axis size number How long the connection is, it's either width or height, depending on the axis. room LibLevelGen.Room The room that the link leads to.","title":"LibLevelGen.RoomLinkData"},{"location":"modules/Room.lua/#liblevelgenroomlinks","text":"Object containing room links for every side of the room. Properties : Name Type Description top LibLevelGen.RoomLinkData[] Link data of the top side of the room. bottom LibLevelGen.RoomLinkData[] Link data of the bottom side of the room. left LibLevelGen.RoomLinkData[] Link data of the left side of the room. right LibLevelGen.RoomLinkData[] Link data of the right side of the room.","title":"LibLevelGen.RoomLinks"},{"location":"modules/Room.lua/#liblevelgenpoint","text":"Simple point interface. Properties : Name Type Description x number x y number y","title":"LibLevelGen.Point"},{"location":"modules/Room.lua/#liblevelgenroom","text":"Object representing a room. Properties : Name Type Description x number X coordinate of the room's top left corner within the segment. y number Y coordinate of the room's top left corner within the segment. w number Width of the room. h number Height of the room. flags number Room flags (from room.Flag ). links LibLevelGen.RoomLinkData[] Information about the rooms adjacent to this room and where exactly the entrances are. padding LibLevelGen.PaddingData | nil Padding override to use instead of the segment-defined one. tiles LibLevelGen.Tile[] Array of tiles in this room. exit LibLevelGen.Point | nil Coordinates of exit stairs within this room (if they exist). instance LibLegelGen.Instance Instance this room belongs to. segment LibLevelGen.Segment Segment this table belongs to. userData table Table where you can put whatever you want safely. Methods :","title":"LibLevelGen.Room"},{"location":"modules/Room.lua/#liblevelgenroomsetflags","text":"setFlags ( self : LibLevelGen . Room , newFlags : number ): void Adds new flags on top of existing flags. Parameters : Name Type Description self LibLevelGen.Room The room. newFlags number The new flags.","title":"LibLevelGen.Room.setFlags"},{"location":"modules/Room.lua/#liblevelgenroomclearflags","text":"clearFlags ( self : LibLevelGen . Room , flagsToClear : number ): void Removes the given flags. Parameters : Name Type Description self LibLevelGen.Room The room. flagsToClear number Flags to remove.","title":"LibLevelGen.Room.clearFlags"},{"location":"modules/Room.lua/#liblevelgenroommaskflags","text":"maskFlags ( self : LibLevelGen . Room , flags : number ): void Removes all flags apart from the given ones. Parameters : Name Type Description self LibLevelGen.Room the room. flags number Flags to use as a mask.","title":"LibLevelGen.Room.maskFlags"},{"location":"modules/Room.lua/#liblevelgenroomcheckflags","text":"checkFlags ( self : LibLevelGen . Room , flags : number ): void Checks if the given flags are set. Parameters : Name Type Description self LibLevelGen.Room The room. flags number Flags to check.","title":"LibLevelGen.Room.checkFlags"},{"location":"modules/Room.lua/#liblevelgenroomsetpaddingtileoverride","text":"setPaddingTileOverride ( self : LibLevelGen . Room , data : LibLevelGen . PaddingData ): void Set the padding that will be used instead of the one specified by the segment. Parameters : Name Type Description self LibLevelGen.Room The room. data LibLevelGen.PaddingData Padding definition object.","title":"LibLevelGen.Room.setPaddingTileOverride"},{"location":"modules/Room.lua/#liblevelgenroomgetbounds","text":"getBounds ( self : LibLevelGen . Room ): number [] Get bounds of the room (in table {x, y, w, h} ). Parameters : Name Type Description self LibLevelGen.Room The room. Returns : number[]","title":"LibLevelGen.Room.getBounds"},{"location":"modules/Room.lua/#liblevelgenroomgetrect","text":"getRect ( self : LibLevelGen . Room ): LibLevelGen . Rect Get rect of the room. Parameters : Name Type Description self LibLevelGen.Room The room. Returns : LibLevelGen.Rect","title":"LibLevelGen.Room.getRect"},{"location":"modules/Room.lua/#liblevelgenroomsettile","text":"setTile ( self : LibLevelGen . Room , x : number , y : number , tileType : string , tileset ? : string ): void Set tile on the given coordinates. If tileset is not specified, the default one of the segment is used. Parameters : Name Type Description self LibLevelGen.Room The room. x number X coordinates of the tile. y number Y coordinates of the tile. tileType string The tile type tileset? string The tileset, if not specified defaults to the tileset of the segment.","title":"LibLevelGen.Room.setTile"},{"location":"modules/Room.lua/#liblevelgenroomgettile","text":"getTile ( self : LibLevelGen . Room , x : number , y : number ): LibLevelGen . Tile Get tile on given coordinates Parameters : Name Type Description self LibLevelGen.Room The room. x number X coordinates of the tile. y number Y coordinates of the tile. Returns : LibLevelGen.Tile","title":"LibLevelGen.Room.getTile"},{"location":"modules/Room.lua/#liblevelgenroomdeletetile","text":"deleteTile ( self : LibLevelGen . Room , x : number , y : number ): void Delete the given tile (set it to Void pseudotile) Parameters : Name Type Description self LibLevelGen.Room The room. x number X coordinates of the tile. y number Y coordinates of the tile.","title":"LibLevelGen.Room.deleteTile"},{"location":"modules/Room.lua/#liblevelgenroomistilenearwall","text":"isTileNearWall ( self : LibLevelGen . Room , tile : LibLevelGen . Tile ): boolean Checks if the given tile (assumed to be within this room) is near a wall tile. Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile The tile to check. Returns : boolean","title":"LibLevelGen.Room.isTileNearWall"},{"location":"modules/Room.lua/#liblevelgenroomistilenearfloor","text":"isTileNearFloor ( self : LibLevelGen . Room , tile : LibLevelGen . Tile ): boolean Checks if the given tile (assumed to be within this room) is near a floor tile. Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile The tile to check. Returns : boolean","title":"LibLevelGen.Room.isTileNearFloor"},{"location":"modules/Room.lua/#liblevelgenroomistilenearborder","text":"isTileNearBorder ( self : LibLevelGen . Room , tile : LibLevelGen . Tile ): boolean Checks if the given tile (assumed to be within this room) is near the edge of the room. Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile The tile to check. Returns : boolean","title":"LibLevelGen.Room.isTileNearBorder"},{"location":"modules/Room.lua/#liblevelgenroomfill","text":"fill ( self : LibLevelGen . Room , parameters : LibLevelGen . RoomFillParameters | string ): void Fill the room. Parameters : Name Type Description self LibLevelGen.Room The room. parameters LibLevelGen.RoomFillParameters | string Either the RoomFillParameters object or simply the tile type string.","title":"LibLevelGen.Room.fill"},{"location":"modules/Room.lua/#liblevelgenroomborder","text":"border ( self : LibLevelGen . Room , parameters : LibLevelGen . RoomBorderParameters | string ): void Create a border around the room. Parameters : Name Type Description self LibLevelGen.Room The room. parameters LibLevelGen.RoomBorderParameters | string Either a RoomBorderParameters specifying the border details, or simply a string tile type to create a basic border.","title":"LibLevelGen.Room.border"},{"location":"modules/Room.lua/#liblevelgenroomselecttiles","text":"selectTiles ( self : LibLevelGen . Room , requirements : LibLevelGen . TileRequirements ): LibLevelGen . Tile [] Returns all tiles that meet the requirements. Parameters : Name Type Description self LibLevelGen.Room The room. requirements LibLevelGen.TileRequirements Tile requirements to check against. Returns : LibLevelGen.Tile[]","title":"LibLevelGen.Room.selectTiles"},{"location":"modules/Room.lua/#liblevelgenroomchooserandomtile","text":"chooseRandomTile ( self : LibLevelGen . Room , requirements : LibLevelGen . TileRequirements ): LibLevelGen . Tile Choose a random tile out of ones that meet requirements Parameters : Name Type Description self LibLevelGen.Room The room. requirements LibLevelGen.TileRequirements Tile requirements to check against. Returns : LibLevelGen.Tile","title":"LibLevelGen.Room.chooseRandomTile"},{"location":"modules/Room.lua/#liblevelgenroomchooserandomtiles","text":"chooseRandomTiles ( self : LibLevelGen . Room , num : number , requirements : LibLevelGen . TileRequirements ): LibLevelGen . Tile [] Choose multiple tiles out of ones that meet requirements. Parameters : Name Type Description self LibLevelGen.Room The room. num number Amount of tiles to choose. requirements LibLevelGen.TileRequirements Tile requirements to check against. Returns : LibLevelGen.Tile[]","title":"LibLevelGen.Room.chooseRandomTiles"},{"location":"modules/Room.lua/#liblevelgenroomplacewalltorch","text":"placeWallTorch ( self : LibLevelGen . Room , tile : LibLevelGen . Tile , type ? : string ): void Place a wall torch on the given tile. Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile Tile to place the torch on. type? string Optional walltorch entity type override.","title":"LibLevelGen.Room.placeWallTorch"},{"location":"modules/Room.lua/#liblevelgenroomplacewalltorches","text":"placeWallTorches ( self : LibLevelGen . Room , num : number , type ? : string ): void Place given amount of wall torches randomly on elligible tiles. Parameters : Name Type Description self LibLevelGen.Room The room. num number Amount of weall torches to place. type? string Optional walltorch entity type override.","title":"LibLevelGen.Room.placeWallTorches"},{"location":"modules/Room.lua/#liblevelgenroomplaceentity","text":"placeEntity ( self : LibLevelGen . Room , tile : LibLevelGen . Tile , entityOrType : string | LibLevelGen . Entity , level ? : number ): void Place entity on the given tile (wrapper around tile:placeEntity that checks if tile is not nil) Parameters : Name Type Description self LibLevelGen.Room The room. tile LibLevelGen.Tile The tile to place the entity on. entityOrType string | LibLevelGen.Entity Existing entity or an entity type to spawn. level? number Optional entity level if passing a string entity type.","title":"LibLevelGen.Room.placeEntity"},{"location":"modules/Room.lua/#liblevelgenroomplaceentityat","text":"placeEntityAt ( self : LibLevelGen . Room , x : number , y : number , entityOrType : string | LibLevelGen . Entity , level ? : number ): void Place entity on a tile on given coordinates. Parameters : Name Type Description self LibLevelGen.Room The room. x number X coordinate. y number Y coordinate. entityOrType string | LibLevelGen.Entity Existing entity or an entity type to spawn. level? number Optional entity level if passing a string entity type.","title":"LibLevelGen.Room.placeEntityAt"},{"location":"modules/Room.lua/#liblevelgenroomplaceentityrand","text":"placeEntityRand ( self : LibLevelGen . Room , requirements : LibLevelGen . TileRequirements , entityOrType : string | LibLevelGen . Entity , level ? : number ): void Place entity on a random tile that meets requrements. Parameters : Name Type Description self LibLevelGen.Room The room. requirements LibLevelGen.TileRequirements Requirements used to select the tile. entityOrType string | LibLevelGen.Entity Existing entity or an entity type to spawn. level? number Optional entity level if passing a string entity type.","title":"LibLevelGen.Room.placeEntityRand"},{"location":"modules/Room.lua/#liblevelgenroomplacewire","text":"placeWire ( self : LibLevelGen . Room , tile : LibLevelGen . Tile , connectivity : number ): void Place wire on the given tile. Parameters : Name Type Description self LibLevelGen.Room The room tile LibLevelGen.Tile Tile to place the wire on. connectivity number Unused, reserved.","title":"LibLevelGen.Room.placeWire"},{"location":"modules/Room.lua/#liblevelgenroommakeexit","text":"makeExit ( self : LibLevelGen . Room , minibosses : table ): void Turn the room into an exit room - set appropriate flags, place the exit stairs and the miniboss. Parameters : Name Type Description self LibLevelGen.Room The room. minibosses table List of possible minibosses, in format: { {\"type1\", level1}, {\"type2\", level2}, ... }","title":"LibLevelGen.Room.makeExit"},{"location":"modules/Room.lua/#liblevelgenroomplaceexit","text":"placeExit ( self : LibLevelGen . Room ): void Place exit somewhere in the room. Parameters : Name Type Description self LibLevelGen.Room The room.","title":"LibLevelGen.Room.placeExit"},{"location":"modules/Room.lua/#liblevelgenroomplaceminiboss","text":"placeMiniboss ( self : LibLevelGen . Room , minibosses : table ): void Place a miniboss in the room (assumes that the room is an exit room). Parameters : Name Type Description self LibLevelGen.Room The room. minibosses table In format {{\"type\", level}, ...} .","title":"LibLevelGen.Room.placeMiniboss"},{"location":"modules/Room.lua/#liblevelgenroomrandomlyconverttiles","text":"randomlyConvertTiles ( self : LibLevelGen . Room , sourceType : string , targetType : string , ratio : number ): void Randomly convert tiles from sourceType to targetType, chance of conversion happening is ratio. Parameters : Name Type Description self LibLevelGen.Room The room. sourceType string Tile type to convert from. targetType string Tile type to convert to. ratio number Chance of the conversion happening, a float between 0.0 and 1.0.","title":"LibLevelGen.Room.randomlyConvertTiles"},{"location":"modules/Room.lua/#liblevelgenroomconverttiles","text":"convertTiles ( self : LibLevelGen . Room , sourceType : string , targetType : string ): void Convert all tiles from source type to target type, preserving their tileset. Parameters : Name Type Description self LibLevelGen.Room The room. sourceType string Tile type to convert from. targetType string Tile type to convert to.","title":"LibLevelGen.Room.convertTiles"},{"location":"modules/Room.lua/#liblevelgenroomspreadtile","text":"spreadTile ( self : LibLevelGen . Room , targetType : string , requirements : LibLevelGen . TileRequirements , minConvert : number , maxConvert : number , initialTile ? : LibLevelGen . Tile ): void Choose 1 tile that meets requirement and convert it and other nearby tiles to target type. Parameters : Name Type Description self LibLevelGen.Room The room. targetType string Tiletype to convert the tiles to. requirements LibLevelGen.TileRequirements The tile requirements used to pick the initial tile and the subsequent tiles. minConvert number Minimum number of tiles to convert. maxConvert number Maximum number of tiles to convert. initialTile? LibLevelGen.Tile Can be used to specify initial tile, instead of choosing it randomly.","title":"LibLevelGen.Room.spreadTile"},{"location":"modules/Room.lua/#liblevelgenroommakeshop","text":"makeShop ( self : LibLevelGen . Room , locked ? : boolean , force ? : boolean ): void Make the room a shop. TODO: move into a separate module Parameters : Name Type Description self LibLevelGen.Room The room locked? boolean Whether the shop should be a locked shop force? boolean Whether to force shopkeeper and items to spawn even if the shopkeeper killed flag is set in runState.","title":"LibLevelGen.Room.makeShop"},{"location":"modules/Room.lua/#liblevelgenroomfillparameters-extends-liblevelgentiledata","text":"no description Properties : Name Type Description tileset string no description type string no description rect LibLevelGen.Rect | nil no description","title":"LibLevelGen.RoomFillParameters extends LibLevelGen.TileData"},{"location":"modules/Room.lua/#liblevelgenroombordersidecount","text":"no description Properties : Name Type Description top number Top tile count. bottom number Bottom tile count. left number Left tile count. right number Right tile count.","title":"LibLevelGen.RoomBorderSideCount"},{"location":"modules/Room.lua/#liblevelgenroomborderparameters-extends-liblevelgentiledata","text":"Object used to specify room border details. Properties : Name Type Description tileset string no description type string no description rect LibLevelGen.Rect The rect around which to place the border. sides LibLevelGen.RoomBorderSideCount Definition of wall count on each side.","title":"LibLevelGen.RoomBorderParameters extends LibLevelGen.TileData"},{"location":"modules/Room.lua/#enums","text":"","title":"Enums"},{"location":"modules/Room.lua/#roomaxis","text":"Used to determine whether a room was generated vertically or horizontally. Entries : VERTICAL HORIZONTAL","title":"room.Axis"},{"location":"modules/Room.lua/#roomflag","text":"Flags which determine the properties of the room Entries : NONE ALLOW_ENEMY ALLOW_CHEST ALLOW_CRATE ALLOW_TRAP ALLOW_TRAVELRUNE ALLOW_SHRINE ALLOW_TORCH ALLOW_TILE_CONVERSION ALLOW_SECRET_FILL EXIT STARTING","title":"room.Flag"},{"location":"modules/Room.lua/#roomtype","text":"Helper enum containing common room.Flag bitmasks. Entries : REGULAR STARTING EXIT CORRIDOR SECRET SHOP SECRET_SHOP OTHER","title":"room.Type"},{"location":"modules/Room.lua/#other","text":"","title":"Other"},{"location":"modules/Room.lua/#roomdirection","text":"room . Direction = action . Direction -- From necro.game.system.Action","title":"room.Direction"},{"location":"modules/Room.lua/#roomdirectionvector","text":"room . DirectionVector = { [ room . Direction . LEFT ] = { - 1 , 0 }, [ room . Direction . RIGHT ] = { 1 , 0 }, [ room . Direction . UP ] = { 0 , - 1 }, [ room . Direction . DOWN ] = { 0 , 1 } }","title":"room.DirectionVector"},{"location":"modules/Room.lua/#tribool-alias","text":"--- @alias TriBool boolean | nil","title":"Tribool alias"},{"location":"modules/SecretRoom.lua/","text":"SecretRoom.lua \u00b6 Functions \u00b6 secretRoom.placeSecretRooms \u00b6 secretRoom . placeSecretRooms ( segment : LibLevelGen . Segment ): LibLevelGen . Room [] Finds suitable locations for secret rooms and places them. Parameters : Name Type Description segment LibLevelGen.Segment no description Returns : LibLevelGen.Room[] secretRoom.fillSecretRooms \u00b6 secretRoom . fillSecretRooms ( segment : LibLevelGen . Segment , fillType : number ? unused , reserved ): void Fills secret rooms in the same way necrolevel does. Parameters : Name Type Description segment LibLevelGen.Segment no description fillType number? unused, reserved no description secretRoom.placeChest \u00b6 secretRoom . placeChest ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretRoom.placeHiddenChest \u00b6 secretRoom . placeHiddenChest ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretRoom.makeCrateRoom \u00b6 secretRoom . makeCrateRoom ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretRoom.makeMouseTrap \u00b6 secretRoom . makeMouseTrap ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretRoom.makeTrapRoom \u00b6 secretRoom . makeTrapRoom ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretRoom.makeBatCave \u00b6 secretRoom . makeBatCave ( room : LibLevelGen . Room , secretBatLevel : number ? ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretBatLevel number? no description secretRoom.makeSkeletonCloset \u00b6 secretRoom . makeSkeletonCloset ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretRoom.placeBombOrGold \u00b6 secretRoom . placeBombOrGold ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretRoom.placeUrn \u00b6 secretRoom . placeUrn ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"SecretRoom.lua"},{"location":"modules/SecretRoom.lua/#secretroomlua","text":"","title":"SecretRoom.lua"},{"location":"modules/SecretRoom.lua/#functions","text":"","title":"Functions"},{"location":"modules/SecretRoom.lua/#secretroomplacesecretrooms","text":"secretRoom . placeSecretRooms ( segment : LibLevelGen . Segment ): LibLevelGen . Room [] Finds suitable locations for secret rooms and places them. Parameters : Name Type Description segment LibLevelGen.Segment no description Returns : LibLevelGen.Room[]","title":"secretRoom.placeSecretRooms"},{"location":"modules/SecretRoom.lua/#secretroomfillsecretrooms","text":"secretRoom . fillSecretRooms ( segment : LibLevelGen . Segment , fillType : number ? unused , reserved ): void Fills secret rooms in the same way necrolevel does. Parameters : Name Type Description segment LibLevelGen.Segment no description fillType number? unused, reserved no description","title":"secretRoom.fillSecretRooms"},{"location":"modules/SecretRoom.lua/#secretroomplacechest","text":"secretRoom . placeChest ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"secretRoom.placeChest"},{"location":"modules/SecretRoom.lua/#secretroomplacehiddenchest","text":"secretRoom . placeHiddenChest ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"secretRoom.placeHiddenChest"},{"location":"modules/SecretRoom.lua/#secretroommakecrateroom","text":"secretRoom . makeCrateRoom ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"secretRoom.makeCrateRoom"},{"location":"modules/SecretRoom.lua/#secretroommakemousetrap","text":"secretRoom . makeMouseTrap ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"secretRoom.makeMouseTrap"},{"location":"modules/SecretRoom.lua/#secretroommaketraproom","text":"secretRoom . makeTrapRoom ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"secretRoom.makeTrapRoom"},{"location":"modules/SecretRoom.lua/#secretroommakebatcave","text":"secretRoom . makeBatCave ( room : LibLevelGen . Room , secretBatLevel : number ? ): void no description Parameters : Name Type Description room LibLevelGen.Room no description secretBatLevel number? no description","title":"secretRoom.makeBatCave"},{"location":"modules/SecretRoom.lua/#secretroommakeskeletoncloset","text":"secretRoom . makeSkeletonCloset ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"secretRoom.makeSkeletonCloset"},{"location":"modules/SecretRoom.lua/#secretroomplacebomborgold","text":"secretRoom . placeBombOrGold ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"secretRoom.placeBombOrGold"},{"location":"modules/SecretRoom.lua/#secretroomplaceurn","text":"secretRoom . placeUrn ( room : LibLevelGen . Room ): void no description Parameters : Name Type Description room LibLevelGen.Room no description","title":"secretRoom.placeUrn"},{"location":"modules/SecretShop.lua/","text":"SecretShop.lua \u00b6 Functions \u00b6 secretShop.createSecretShopLevelNumbers \u00b6 secretShop . createSecretShopLevelNumbers ( generatorData : LibLevelGen . Config \\ , rng : LibLevelGen . Rng ): table < number , number > no description Parameters : Name Type Description generatorData LibLevelGen.Config\\ no description rng LibLevelGen.Rng no description Returns : table<number,number> secretShop.register \u00b6 secretShop . register ( name : string , args : LibLevelGen . SecretShop ): number no description Parameters : Name Type Description name string no description args LibLevelGen.SecretShop no description Returns : number secretShop.getData \u00b6 secretShop . getData ( shopType : number ): LibLevelGen . SecretShop no description Parameters : Name Type Description shopType number From the secretShop.Type enum. Returns : LibLevelGen.SecretShop Classes \u00b6 LibLevelGen.SecretShop \u00b6 no description Properties : Name Type Description name string friendlyName for logging/error message purposes w number (default: 7) - width of the room h number (default: 10) - height of the room runeX number (default: 3) - x position of the travel rune runeY number (default: 7) - y position of the travel rune canHaveSSS boolean (default: false) - determines whether a super secret shop can be created above the secret shop tileType string (default: StoneWallCracked) - wall where the rune spawns will be converted to this type convertibleTiles string[] (default: {\"DirtWall\", \"StoneWall\", \"CatacombWall\"}) - tiles where the rune can be placed. Will be converted to tile specified by tileType. runeType string entity type of the shop travel rune clb fun(room: LibLevelGen.Room) callback function that gets called with the room as the parameter when the shop is spawned levelRange number[] range of level numbers on which the shop is allowed to spawn, in format {minLvl, maxLvl} (inclusive). If not specified, there are no restrictions (apart from not being able to spawn on boss levels) SSScurrency string no description Enums \u00b6 secretShop.Type \u00b6 no description Entries : TRANSMOGRIFIER ARENA BLOOD_SHOP GLASS_SHOP FOOD_SHOP CONJURER SHRINER PAWNBROKER","title":"SecretShop.lua"},{"location":"modules/SecretShop.lua/#secretshoplua","text":"","title":"SecretShop.lua"},{"location":"modules/SecretShop.lua/#functions","text":"","title":"Functions"},{"location":"modules/SecretShop.lua/#secretshopcreatesecretshoplevelnumbers","text":"secretShop . createSecretShopLevelNumbers ( generatorData : LibLevelGen . Config \\ , rng : LibLevelGen . Rng ): table < number , number > no description Parameters : Name Type Description generatorData LibLevelGen.Config\\ no description rng LibLevelGen.Rng no description Returns : table<number,number>","title":"secretShop.createSecretShopLevelNumbers"},{"location":"modules/SecretShop.lua/#secretshopregister","text":"secretShop . register ( name : string , args : LibLevelGen . SecretShop ): number no description Parameters : Name Type Description name string no description args LibLevelGen.SecretShop no description Returns : number","title":"secretShop.register"},{"location":"modules/SecretShop.lua/#secretshopgetdata","text":"secretShop . getData ( shopType : number ): LibLevelGen . SecretShop no description Parameters : Name Type Description shopType number From the secretShop.Type enum. Returns : LibLevelGen.SecretShop","title":"secretShop.getData"},{"location":"modules/SecretShop.lua/#classes","text":"","title":"Classes"},{"location":"modules/SecretShop.lua/#liblevelgensecretshop","text":"no description Properties : Name Type Description name string friendlyName for logging/error message purposes w number (default: 7) - width of the room h number (default: 10) - height of the room runeX number (default: 3) - x position of the travel rune runeY number (default: 7) - y position of the travel rune canHaveSSS boolean (default: false) - determines whether a super secret shop can be created above the secret shop tileType string (default: StoneWallCracked) - wall where the rune spawns will be converted to this type convertibleTiles string[] (default: {\"DirtWall\", \"StoneWall\", \"CatacombWall\"}) - tiles where the rune can be placed. Will be converted to tile specified by tileType. runeType string entity type of the shop travel rune clb fun(room: LibLevelGen.Room) callback function that gets called with the room as the parameter when the shop is spawned levelRange number[] range of level numbers on which the shop is allowed to spawn, in format {minLvl, maxLvl} (inclusive). If not specified, there are no restrictions (apart from not being able to spawn on boss levels) SSScurrency string no description","title":"LibLevelGen.SecretShop"},{"location":"modules/SecretShop.lua/#enums","text":"","title":"Enums"},{"location":"modules/SecretShop.lua/#secretshoptype","text":"no description Entries : TRANSMOGRIFIER ARENA BLOOD_SHOP GLASS_SHOP FOOD_SHOP CONJURER SHRINER PAWNBROKER","title":"secretShop.Type"},{"location":"modules/Segment.lua/","text":"Segment.lua \u00b6 Functions \u00b6 segment.new \u00b6 segment . new ( instance : LibLegelGen . Instance ): LibLevelGen . Segment no description Parameters : Name Type Description instance LibLegelGen.Instance no description Returns : LibLevelGen.Segment segment.createRandLinkedRoomParameterCombinations \u00b6 segment . createRandLinkedRoomParameterCombinations ( parameters : LibLevelGen . RoomGenCombinations ): LibLevelGen . RoomGenCombination [] no description Parameters : Name Type Description parameters LibLevelGen.RoomGenCombinations no description Returns : LibLevelGen.RoomGenCombination[] Classes \u00b6 LibLevelGen.RoomGenCombination \u00b6 no description Properties : Name Type Description direction number no description corridorEntrance number no description corridorExit number no description corridorThickness number no description corridorLength number no description roomWidth number no description roomHeight number no description clearCorridor boolean no description entranceTileChances table<string,number> no description exitTileChances table<string,number> no description LibLevelGen.RoomGenCombinations \u00b6 no description Properties : Name Type Description direction number[] no description corridorEntrance number[] no description corridorExit number[] no description corridorThickness number[] no description corridorLength number[] no description roomWidth number[] no description roomHeight number[] no description clearCorridor boolean no description entranceTileChances table<string,number> no description exitTileChances table<string,number> no description LibLegelGen.RoomGenResult \u00b6 no description Properties : Name Type Description axis number no description corridorX number no description corridorY number no description roomCorridorX number no description roomCorridorY number no description combination LibLevelGen.RoomGenCombination no description LibLevelGen.TileData \u00b6 no description Properties : Name Type Description tileset string no description type string no description LibLevelGen.PaddingExtraTileData extends LibLevelGen.TileData \u00b6 no description Properties : Name Type Description tileset string no description type string no description ratio number no description LibLevelGen.PaddingData \u00b6 no description Properties : Name Type Description mainTile LibLevelGen.TileData no description extraTiles LibLevelGen.PaddingExtraTileData[] no description count number no description LibLevelGen.Rect \u00b6 no description Properties : Name Type Description x number no description y number no description w number no description h number no description LibLevelGen.Segment \u00b6 no description Properties : Name Type Description instance LibLegelGen.Instance The instance that created this segment. no description rooms LibLevelGen.Room[] Rooms within this segment. no description padding table Wall padding that's applied to rooms when serializing the segment. no description tileset string The default tileset that's used if not specified no description roomBorder string Tile type that's used for walls in newly created rooms. no description corridorBorder string Tile type that's used for walls in newly created corridors. no description chestsLeft number chests that have yet to be placed. no description cratesLeft number of crates that have yet to be placed. no description forceSecretRoomBomb boolean Determines whether 1st secret room will be forcefully filled with a bomb (used when locked shop spawns) no description Methods : LibLevelGen.Segment.setNumberOfChests \u00b6 setNumberOfChests ( self : LibLevelGen . Segment , chests : number ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description chests number no description LibLevelGen.Segment.setNumberOfCrates \u00b6 setNumberOfCrates ( self : LibLevelGen . Segment , crates : number ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description crates number no description LibLevelGen.Segment.setTileset \u00b6 setTileset ( self : LibLevelGen . Segment , tilesetName : string ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description tilesetName string no description LibLevelGen.Segment.setRoomBorder \u00b6 setRoomBorder ( self : LibLevelGen . Segment , roomBorder : string ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description roomBorder string no description LibLevelGen.Segment.setCorridorBorder \u00b6 setCorridorBorder ( self : LibLevelGen . Segment , corridorBorder : string ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description corridorBorder string no description LibLevelGen.Segment.setPadding \u00b6 setPadding ( self : LibLevelGen . Segment , data : LibLevelGen . PaddingData ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description data LibLevelGen.PaddingData no description LibLevelGen.Segment.getRandomPaddingTile \u00b6 getRandomPaddingTile ( self : LibLevelGen . Segment , padding : LibLevelGen . PaddingData ): LibLevelGen . TileData no description Parameters : Name Type Description self LibLevelGen.Segment no description padding LibLevelGen.PaddingData no description Returns : LibLevelGen.TileData LibLevelGen.Segment.createRoom \u00b6 createRoom ( self : LibLevelGen . Segment , x : number , y : number , w : number , h : number , flags : number ? ): LibLevelGen . Room no description Parameters : Name Type Description self LibLevelGen.Segment no description x number no description y number no description w number no description h number no description flags number? no description Returns : LibLevelGen.Room LibLevelGen.Segment.createStartingRoom \u00b6 createStartingRoom ( self : LibLevelGen . Segment ): LibLevelGen . Room Creates a starting room. Parameters : Name Type Description self LibLevelGen.Segment no description Returns : LibLevelGen.Room LibLevelGen.Segment.placeWallTorches \u00b6 placeWallTorches ( self : LibLevelGen . Segment , torchesPerRoom : number ): void Places specified amount of torches in rooms that allow it. Parameters : Name Type Description self LibLevelGen.Segment no description torchesPerRoom number no description LibLevelGen.Segment.selectRooms \u00b6 selectRooms ( self : LibLevelGen . Segment , flags : number ): LibLevelGen . Room [] Select rooms that match the given flags. Parameters : Name Type Description self LibLevelGen.Segment no description flags number no description Returns : LibLevelGen.Room[] LibLevelGen.Segment.iterateRooms \u00b6 iterateRooms ( self : LibLevelGen . Segment , flags : number , clb : fun ( room : LibLevelGen . Room )): void Call the specified callback function for every room that matches the given flags. Parameters : Name Type Description self LibLevelGen.Segment no description flags number no description clb fun(room: LibLevelGen.Room) no description LibLevelGen.Segment.randomlyConvertTiles \u00b6 randomlyConvertTiles ( self : LibLevelGen . Segment , sourceType : string , targetType : string , ratio : number ): void Randomly convert tiles from sourceType to targetType in rooms that allow tile conversions. Chance to convert a given tile is specified by ratio. Parameters : Name Type Description self LibLevelGen.Segment no description sourceType string no description targetType string no description ratio number no description LibLevelGen.Segment.createRandLinkedRoom \u00b6 createRandLinkedRoom ( self : LibLevelGen . Segment , roomToLink : LibLevelGen . Room , rotateRoom : boolean , orgCombinations : LibLevelGen . RoomGenCombination []): LibLevelGen . Room newCorridor , LibLevelGen . Room newRoom , LibLegelGen . RoomGenResult result no description Parameters : Name Type Description self LibLevelGen.Segment no description roomToLink LibLevelGen.Room no description rotateRoom boolean no description orgCombinations LibLevelGen.RoomGenCombination[] no description Returns : LibLevelGen.Room newCorridor, LibLevelGen.Room newRoom, LibLegelGen.RoomGenResult result LibLevelGen.Segment.createLinkedRoom \u00b6 createLinkedRoom ( self : LibLevelGen . Segment , roomToLink : LibLevelGen . Room , axis : number , corridorX : number , corridorY : number , corridorW : number , corridorH : number , roomCorridorX : number , roomCorridorY : number , roomW : number , roomH : number ): LibLevelGen . Room newCorridor , LibLevelGen . Room newRoom no description Parameters : Name Type Description self LibLevelGen.Segment no description roomToLink LibLevelGen.Room no description axis number no description corridorX number no description corridorY number no description corridorW number no description corridorH number no description roomCorridorX number no description roomCorridorY number no description roomW number no description roomH number no description Returns : LibLevelGen.Room newCorridor, LibLevelGen.Room newRoom LibLevelGen.Segment.rectOverlapsWithAnyRoom \u00b6 rectOverlapsWithAnyRoom ( self : LibLevelGen . Segment , rect : LibLevelGen . Rect ): LibLevelGen . Room | nil Checks whether the given rect overlaps with any room, and returns the 1st room that overlapped. Parameters : Name Type Description self LibLevelGen.Segment no description rect LibLevelGen.Rect no description Returns : LibLevelGen.Room | nil LibLevelGen.Segment.rectOverlappedRooms \u00b6 rectOverlappedRooms ( self : LibLevelGen . Segment , rect : LibLevelGen . Rect ): LibLevelGen . Room [] Return all rooms that overlap with the given rect. Parameters : Name Type Description self LibLevelGen.Segment no description rect LibLevelGen.Rect no description Returns : LibLevelGen.Room[] LibLevelGen.Segment.rectInBounds \u00b6 rectInBounds ( self : LibLevelGen . Segment , rect : LibLevelGen . Rect , bounds : number []): boolean Check whether the given rect is within bounds of the segment. Parameters : Name Type Description self LibLevelGen.Segment no description rect LibLevelGen.Rect no description bounds number[] no description Returns : boolean LibLevelGen.Segment.findBetweenRoomRects \u00b6 findBetweenRoomRects ( self : LibLevelGen . Segment , minWidth : number , minHeight : number ): LibLevelGen . OverlappedRect [] Find rects between rooms of the segment, of minimum width and height. Parameters : Name Type Description self LibLevelGen.Segment no description minWidth number no description minHeight number no description Returns : LibLevelGen.OverlappedRect[] LibLevelGen.Segment.beetweenRoomRectSidesWithAdjecentRooms \u00b6 beetweenRoomRectSidesWithAdjecentRooms ( self : LibLevelGen . Segment , betweenRoomRect : LibLevelGen . OverlappedRect ): boolean Counts how many sides of an overlappedRect are adjacent to a room, including other overlapped rects. Parameters : Name Type Description self LibLevelGen.Segment no description betweenRoomRect LibLevelGen.OverlappedRect no description Returns : boolean LibLevelGen.Segment.beetweenRoomRectAdjecentFakeRooms \u00b6 beetweenRoomRectAdjecentFakeRooms ( self : LibLevelGen . Segment , betweenRect : LibLevelGen . OverlappedRect ): number Counts how many \"fake rooms\" (other overlapped rects) are adjacent to this overlapped rect. Parameters : Name Type Description self LibLevelGen.Segment no description betweenRect LibLevelGen.OverlappedRect no description Returns : number LibLevelGen.Segment.determineBounds \u00b6 determineBounds ( self : LibLevelGen . Segment ): number [] Detemine bounds of the segment. Parameters : Name Type Description self LibLevelGen.Segment no description Returns : number[] LibLevelGen.Overlaps \u00b6 no description Properties : Name Type Description top LibLevelGen.Room[] no description bottom LibLevelGen.Room[] no description left LibLevelGen.Room[] no description right LibLevelGen.Room[] no description LibLevelGen.OverlappedRect extends LibLevelGen.Rect \u00b6 no description Properties : Name Type Description x number no description y number no description w number no description h number no description overlaps LibLevelGen.Overlaps no description","title":"Segment.lua"},{"location":"modules/Segment.lua/#segmentlua","text":"","title":"Segment.lua"},{"location":"modules/Segment.lua/#functions","text":"","title":"Functions"},{"location":"modules/Segment.lua/#segmentnew","text":"segment . new ( instance : LibLegelGen . Instance ): LibLevelGen . Segment no description Parameters : Name Type Description instance LibLegelGen.Instance no description Returns : LibLevelGen.Segment","title":"segment.new"},{"location":"modules/Segment.lua/#segmentcreaterandlinkedroomparametercombinations","text":"segment . createRandLinkedRoomParameterCombinations ( parameters : LibLevelGen . RoomGenCombinations ): LibLevelGen . RoomGenCombination [] no description Parameters : Name Type Description parameters LibLevelGen.RoomGenCombinations no description Returns : LibLevelGen.RoomGenCombination[]","title":"segment.createRandLinkedRoomParameterCombinations"},{"location":"modules/Segment.lua/#classes","text":"","title":"Classes"},{"location":"modules/Segment.lua/#liblevelgenroomgencombination","text":"no description Properties : Name Type Description direction number no description corridorEntrance number no description corridorExit number no description corridorThickness number no description corridorLength number no description roomWidth number no description roomHeight number no description clearCorridor boolean no description entranceTileChances table<string,number> no description exitTileChances table<string,number> no description","title":"LibLevelGen.RoomGenCombination"},{"location":"modules/Segment.lua/#liblevelgenroomgencombinations","text":"no description Properties : Name Type Description direction number[] no description corridorEntrance number[] no description corridorExit number[] no description corridorThickness number[] no description corridorLength number[] no description roomWidth number[] no description roomHeight number[] no description clearCorridor boolean no description entranceTileChances table<string,number> no description exitTileChances table<string,number> no description","title":"LibLevelGen.RoomGenCombinations"},{"location":"modules/Segment.lua/#liblegelgenroomgenresult","text":"no description Properties : Name Type Description axis number no description corridorX number no description corridorY number no description roomCorridorX number no description roomCorridorY number no description combination LibLevelGen.RoomGenCombination no description","title":"LibLegelGen.RoomGenResult"},{"location":"modules/Segment.lua/#liblevelgentiledata","text":"no description Properties : Name Type Description tileset string no description type string no description","title":"LibLevelGen.TileData"},{"location":"modules/Segment.lua/#liblevelgenpaddingextratiledata-extends-liblevelgentiledata","text":"no description Properties : Name Type Description tileset string no description type string no description ratio number no description","title":"LibLevelGen.PaddingExtraTileData extends LibLevelGen.TileData"},{"location":"modules/Segment.lua/#liblevelgenpaddingdata","text":"no description Properties : Name Type Description mainTile LibLevelGen.TileData no description extraTiles LibLevelGen.PaddingExtraTileData[] no description count number no description","title":"LibLevelGen.PaddingData"},{"location":"modules/Segment.lua/#liblevelgenrect","text":"no description Properties : Name Type Description x number no description y number no description w number no description h number no description","title":"LibLevelGen.Rect"},{"location":"modules/Segment.lua/#liblevelgensegment","text":"no description Properties : Name Type Description instance LibLegelGen.Instance The instance that created this segment. no description rooms LibLevelGen.Room[] Rooms within this segment. no description padding table Wall padding that's applied to rooms when serializing the segment. no description tileset string The default tileset that's used if not specified no description roomBorder string Tile type that's used for walls in newly created rooms. no description corridorBorder string Tile type that's used for walls in newly created corridors. no description chestsLeft number chests that have yet to be placed. no description cratesLeft number of crates that have yet to be placed. no description forceSecretRoomBomb boolean Determines whether 1st secret room will be forcefully filled with a bomb (used when locked shop spawns) no description Methods :","title":"LibLevelGen.Segment"},{"location":"modules/Segment.lua/#liblevelgensegmentsetnumberofchests","text":"setNumberOfChests ( self : LibLevelGen . Segment , chests : number ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description chests number no description","title":"LibLevelGen.Segment.setNumberOfChests"},{"location":"modules/Segment.lua/#liblevelgensegmentsetnumberofcrates","text":"setNumberOfCrates ( self : LibLevelGen . Segment , crates : number ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description crates number no description","title":"LibLevelGen.Segment.setNumberOfCrates"},{"location":"modules/Segment.lua/#liblevelgensegmentsettileset","text":"setTileset ( self : LibLevelGen . Segment , tilesetName : string ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description tilesetName string no description","title":"LibLevelGen.Segment.setTileset"},{"location":"modules/Segment.lua/#liblevelgensegmentsetroomborder","text":"setRoomBorder ( self : LibLevelGen . Segment , roomBorder : string ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description roomBorder string no description","title":"LibLevelGen.Segment.setRoomBorder"},{"location":"modules/Segment.lua/#liblevelgensegmentsetcorridorborder","text":"setCorridorBorder ( self : LibLevelGen . Segment , corridorBorder : string ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description corridorBorder string no description","title":"LibLevelGen.Segment.setCorridorBorder"},{"location":"modules/Segment.lua/#liblevelgensegmentsetpadding","text":"setPadding ( self : LibLevelGen . Segment , data : LibLevelGen . PaddingData ): void no description Parameters : Name Type Description self LibLevelGen.Segment no description data LibLevelGen.PaddingData no description","title":"LibLevelGen.Segment.setPadding"},{"location":"modules/Segment.lua/#liblevelgensegmentgetrandompaddingtile","text":"getRandomPaddingTile ( self : LibLevelGen . Segment , padding : LibLevelGen . PaddingData ): LibLevelGen . TileData no description Parameters : Name Type Description self LibLevelGen.Segment no description padding LibLevelGen.PaddingData no description Returns : LibLevelGen.TileData","title":"LibLevelGen.Segment.getRandomPaddingTile"},{"location":"modules/Segment.lua/#liblevelgensegmentcreateroom","text":"createRoom ( self : LibLevelGen . Segment , x : number , y : number , w : number , h : number , flags : number ? ): LibLevelGen . Room no description Parameters : Name Type Description self LibLevelGen.Segment no description x number no description y number no description w number no description h number no description flags number? no description Returns : LibLevelGen.Room","title":"LibLevelGen.Segment.createRoom"},{"location":"modules/Segment.lua/#liblevelgensegmentcreatestartingroom","text":"createStartingRoom ( self : LibLevelGen . Segment ): LibLevelGen . Room Creates a starting room. Parameters : Name Type Description self LibLevelGen.Segment no description Returns : LibLevelGen.Room","title":"LibLevelGen.Segment.createStartingRoom"},{"location":"modules/Segment.lua/#liblevelgensegmentplacewalltorches","text":"placeWallTorches ( self : LibLevelGen . Segment , torchesPerRoom : number ): void Places specified amount of torches in rooms that allow it. Parameters : Name Type Description self LibLevelGen.Segment no description torchesPerRoom number no description","title":"LibLevelGen.Segment.placeWallTorches"},{"location":"modules/Segment.lua/#liblevelgensegmentselectrooms","text":"selectRooms ( self : LibLevelGen . Segment , flags : number ): LibLevelGen . Room [] Select rooms that match the given flags. Parameters : Name Type Description self LibLevelGen.Segment no description flags number no description Returns : LibLevelGen.Room[]","title":"LibLevelGen.Segment.selectRooms"},{"location":"modules/Segment.lua/#liblevelgensegmentiteraterooms","text":"iterateRooms ( self : LibLevelGen . Segment , flags : number , clb : fun ( room : LibLevelGen . Room )): void Call the specified callback function for every room that matches the given flags. Parameters : Name Type Description self LibLevelGen.Segment no description flags number no description clb fun(room: LibLevelGen.Room) no description","title":"LibLevelGen.Segment.iterateRooms"},{"location":"modules/Segment.lua/#liblevelgensegmentrandomlyconverttiles","text":"randomlyConvertTiles ( self : LibLevelGen . Segment , sourceType : string , targetType : string , ratio : number ): void Randomly convert tiles from sourceType to targetType in rooms that allow tile conversions. Chance to convert a given tile is specified by ratio. Parameters : Name Type Description self LibLevelGen.Segment no description sourceType string no description targetType string no description ratio number no description","title":"LibLevelGen.Segment.randomlyConvertTiles"},{"location":"modules/Segment.lua/#liblevelgensegmentcreaterandlinkedroom","text":"createRandLinkedRoom ( self : LibLevelGen . Segment , roomToLink : LibLevelGen . Room , rotateRoom : boolean , orgCombinations : LibLevelGen . RoomGenCombination []): LibLevelGen . Room newCorridor , LibLevelGen . Room newRoom , LibLegelGen . RoomGenResult result no description Parameters : Name Type Description self LibLevelGen.Segment no description roomToLink LibLevelGen.Room no description rotateRoom boolean no description orgCombinations LibLevelGen.RoomGenCombination[] no description Returns : LibLevelGen.Room newCorridor, LibLevelGen.Room newRoom, LibLegelGen.RoomGenResult result","title":"LibLevelGen.Segment.createRandLinkedRoom"},{"location":"modules/Segment.lua/#liblevelgensegmentcreatelinkedroom","text":"createLinkedRoom ( self : LibLevelGen . Segment , roomToLink : LibLevelGen . Room , axis : number , corridorX : number , corridorY : number , corridorW : number , corridorH : number , roomCorridorX : number , roomCorridorY : number , roomW : number , roomH : number ): LibLevelGen . Room newCorridor , LibLevelGen . Room newRoom no description Parameters : Name Type Description self LibLevelGen.Segment no description roomToLink LibLevelGen.Room no description axis number no description corridorX number no description corridorY number no description corridorW number no description corridorH number no description roomCorridorX number no description roomCorridorY number no description roomW number no description roomH number no description Returns : LibLevelGen.Room newCorridor, LibLevelGen.Room newRoom","title":"LibLevelGen.Segment.createLinkedRoom"},{"location":"modules/Segment.lua/#liblevelgensegmentrectoverlapswithanyroom","text":"rectOverlapsWithAnyRoom ( self : LibLevelGen . Segment , rect : LibLevelGen . Rect ): LibLevelGen . Room | nil Checks whether the given rect overlaps with any room, and returns the 1st room that overlapped. Parameters : Name Type Description self LibLevelGen.Segment no description rect LibLevelGen.Rect no description Returns : LibLevelGen.Room | nil","title":"LibLevelGen.Segment.rectOverlapsWithAnyRoom"},{"location":"modules/Segment.lua/#liblevelgensegmentrectoverlappedrooms","text":"rectOverlappedRooms ( self : LibLevelGen . Segment , rect : LibLevelGen . Rect ): LibLevelGen . Room [] Return all rooms that overlap with the given rect. Parameters : Name Type Description self LibLevelGen.Segment no description rect LibLevelGen.Rect no description Returns : LibLevelGen.Room[]","title":"LibLevelGen.Segment.rectOverlappedRooms"},{"location":"modules/Segment.lua/#liblevelgensegmentrectinbounds","text":"rectInBounds ( self : LibLevelGen . Segment , rect : LibLevelGen . Rect , bounds : number []): boolean Check whether the given rect is within bounds of the segment. Parameters : Name Type Description self LibLevelGen.Segment no description rect LibLevelGen.Rect no description bounds number[] no description Returns : boolean","title":"LibLevelGen.Segment.rectInBounds"},{"location":"modules/Segment.lua/#liblevelgensegmentfindbetweenroomrects","text":"findBetweenRoomRects ( self : LibLevelGen . Segment , minWidth : number , minHeight : number ): LibLevelGen . OverlappedRect [] Find rects between rooms of the segment, of minimum width and height. Parameters : Name Type Description self LibLevelGen.Segment no description minWidth number no description minHeight number no description Returns : LibLevelGen.OverlappedRect[]","title":"LibLevelGen.Segment.findBetweenRoomRects"},{"location":"modules/Segment.lua/#liblevelgensegmentbeetweenroomrectsideswithadjecentrooms","text":"beetweenRoomRectSidesWithAdjecentRooms ( self : LibLevelGen . Segment , betweenRoomRect : LibLevelGen . OverlappedRect ): boolean Counts how many sides of an overlappedRect are adjacent to a room, including other overlapped rects. Parameters : Name Type Description self LibLevelGen.Segment no description betweenRoomRect LibLevelGen.OverlappedRect no description Returns : boolean","title":"LibLevelGen.Segment.beetweenRoomRectSidesWithAdjecentRooms"},{"location":"modules/Segment.lua/#liblevelgensegmentbeetweenroomrectadjecentfakerooms","text":"beetweenRoomRectAdjecentFakeRooms ( self : LibLevelGen . Segment , betweenRect : LibLevelGen . OverlappedRect ): number Counts how many \"fake rooms\" (other overlapped rects) are adjacent to this overlapped rect. Parameters : Name Type Description self LibLevelGen.Segment no description betweenRect LibLevelGen.OverlappedRect no description Returns : number","title":"LibLevelGen.Segment.beetweenRoomRectAdjecentFakeRooms"},{"location":"modules/Segment.lua/#liblevelgensegmentdeterminebounds","text":"determineBounds ( self : LibLevelGen . Segment ): number [] Detemine bounds of the segment. Parameters : Name Type Description self LibLevelGen.Segment no description Returns : number[]","title":"LibLevelGen.Segment.determineBounds"},{"location":"modules/Segment.lua/#liblevelgenoverlaps","text":"no description Properties : Name Type Description top LibLevelGen.Room[] no description bottom LibLevelGen.Room[] no description left LibLevelGen.Room[] no description right LibLevelGen.Room[] no description","title":"LibLevelGen.Overlaps"},{"location":"modules/Segment.lua/#liblevelgenoverlappedrect-extends-liblevelgenrect","text":"no description Properties : Name Type Description x number no description y number no description w number no description h number no description overlaps LibLevelGen.Overlaps no description","title":"LibLevelGen.OverlappedRect extends LibLevelGen.Rect"},{"location":"modules/Settings.lua/","text":"Settings.lua \u00b6 Functions \u00b6 levelgenSettings.setDefaultGenerator \u00b6 levelgenSettings . setDefaultGenerator ( type : number ): void no description Parameters : Name Type Description type number no description levelgenSettings.retryOnFailmap \u00b6 levelgenSettings . retryOnFailmap (): boolean no description Returns : boolean levelgenSettings.enableErrorLogging \u00b6 levelgenSettings . enableErrorLogging (): boolean no description Returns : boolean Enums \u00b6 levelgenSettings.Generator \u00b6 no description Entries : DEFAULT NECROLEVEL","title":"Settings.lua"},{"location":"modules/Settings.lua/#settingslua","text":"","title":"Settings.lua"},{"location":"modules/Settings.lua/#functions","text":"","title":"Functions"},{"location":"modules/Settings.lua/#levelgensettingssetdefaultgenerator","text":"levelgenSettings . setDefaultGenerator ( type : number ): void no description Parameters : Name Type Description type number no description","title":"levelgenSettings.setDefaultGenerator"},{"location":"modules/Settings.lua/#levelgensettingsretryonfailmap","text":"levelgenSettings . retryOnFailmap (): boolean no description Returns : boolean","title":"levelgenSettings.retryOnFailmap"},{"location":"modules/Settings.lua/#levelgensettingsenableerrorlogging","text":"levelgenSettings . enableErrorLogging (): boolean no description Returns : boolean","title":"levelgenSettings.enableErrorLogging"},{"location":"modules/Settings.lua/#enums","text":"","title":"Enums"},{"location":"modules/Settings.lua/#levelgensettingsgenerator","text":"no description Entries : DEFAULT NECROLEVEL","title":"levelgenSettings.Generator"},{"location":"modules/Shrine.lua/","text":"Shrine.lua \u00b6 Functions \u00b6 shrine.createShrineLevelNumbers \u00b6 shrine . createShrineLevelNumbers ( seenShrines : number [], generatorData : LibLevelGen . Config , rng : LibLevelGen . Rng ): table < number , number > no description Parameters : Name Type Description seenShrines number[] no description generatorData LibLevelGen.Config no description rng LibLevelGen.Rng no description Returns : table<number,number> shrine.getElligibleShrines \u00b6 shrine . getElligibleShrines ( seenShrines : number [], generatorData : LibLevelGen . Config ): number [] no description Parameters : Name Type Description seenShrines number[] no description generatorData LibLevelGen.Config no description Returns : number[] shrine.markSeen \u00b6 shrine . markSeen ( shrineType : number , seenShrines : number []): void no description Parameters : Name Type Description shrineType number no description seenShrines number[] no description shrine.checkWasSeen \u00b6 shrine . checkWasSeen ( shrineType : number , seenShrines : number []): boolean no description Parameters : Name Type Description shrineType number no description seenShrines number[] no description Returns : boolean shrine.register \u00b6 shrine . register ( name : string , args : LibLevelGen . Shrine ): number no description Parameters : Name Type Description name string no description args LibLevelGen.Shrine no description Returns : number shrine.getData \u00b6 shrine . getData ( type : string ): LibLevelGen . Shrine no description Parameters : Name Type Description type string no description Returns : LibLevelGen.Shrine Classes \u00b6 LibLevelGen.Shrine \u00b6 no description Properties : Name Type Description name string no description xmlID number no description old boolean no description notAllowedInShriner boolean no description Enums \u00b6 shrine.ID \u00b6 TEST SHRINE ENUM COMMENT Entries : BLOOD DARKNESS GLASS PEACE RHYTHM RISK SACRIFICE SPACE WAR NO_RETURN PHASING PACE CHANCE BOSS PAIN UNCERTAINTY shrine.Type \u00b6 no description Entries : BLOOD DARKNESS GLASS PEACE RHYTHM RISK SACRIFICE SPACE WAR NO_RETURN PHASING PACE CHANCE BOSS PAIN UNCERTAINTY","title":"Shrine.lua"},{"location":"modules/Shrine.lua/#shrinelua","text":"","title":"Shrine.lua"},{"location":"modules/Shrine.lua/#functions","text":"","title":"Functions"},{"location":"modules/Shrine.lua/#shrinecreateshrinelevelnumbers","text":"shrine . createShrineLevelNumbers ( seenShrines : number [], generatorData : LibLevelGen . Config , rng : LibLevelGen . Rng ): table < number , number > no description Parameters : Name Type Description seenShrines number[] no description generatorData LibLevelGen.Config no description rng LibLevelGen.Rng no description Returns : table<number,number>","title":"shrine.createShrineLevelNumbers"},{"location":"modules/Shrine.lua/#shrinegetelligibleshrines","text":"shrine . getElligibleShrines ( seenShrines : number [], generatorData : LibLevelGen . Config ): number [] no description Parameters : Name Type Description seenShrines number[] no description generatorData LibLevelGen.Config no description Returns : number[]","title":"shrine.getElligibleShrines"},{"location":"modules/Shrine.lua/#shrinemarkseen","text":"shrine . markSeen ( shrineType : number , seenShrines : number []): void no description Parameters : Name Type Description shrineType number no description seenShrines number[] no description","title":"shrine.markSeen"},{"location":"modules/Shrine.lua/#shrinecheckwasseen","text":"shrine . checkWasSeen ( shrineType : number , seenShrines : number []): boolean no description Parameters : Name Type Description shrineType number no description seenShrines number[] no description Returns : boolean","title":"shrine.checkWasSeen"},{"location":"modules/Shrine.lua/#shrineregister","text":"shrine . register ( name : string , args : LibLevelGen . Shrine ): number no description Parameters : Name Type Description name string no description args LibLevelGen.Shrine no description Returns : number","title":"shrine.register"},{"location":"modules/Shrine.lua/#shrinegetdata","text":"shrine . getData ( type : string ): LibLevelGen . Shrine no description Parameters : Name Type Description type string no description Returns : LibLevelGen.Shrine","title":"shrine.getData"},{"location":"modules/Shrine.lua/#classes","text":"","title":"Classes"},{"location":"modules/Shrine.lua/#liblevelgenshrine","text":"no description Properties : Name Type Description name string no description xmlID number no description old boolean no description notAllowedInShriner boolean no description","title":"LibLevelGen.Shrine"},{"location":"modules/Shrine.lua/#enums","text":"","title":"Enums"},{"location":"modules/Shrine.lua/#shrineid","text":"TEST SHRINE ENUM COMMENT Entries : BLOOD DARKNESS GLASS PEACE RHYTHM RISK SACRIFICE SPACE WAR NO_RETURN PHASING PACE CHANCE BOSS PAIN UNCERTAINTY","title":"shrine.ID"},{"location":"modules/Shrine.lua/#shrinetype","text":"no description Entries : BLOOD DARKNESS GLASS PEACE RHYTHM RISK SACRIFICE SPACE WAR NO_RETURN PHASING PACE CHANCE BOSS PAIN UNCERTAINTY","title":"shrine.Type"},{"location":"modules/Util.lua/","text":"Util.lua \u00b6 Other \u00b6 levelGenUtil.TileRequirements helper table \u00b6 levelGenUtil . TileRequirements = { Enemy = { Generic = { isFloor = true , levelExit = false , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , }, NotNearWall = { isFloor = true , levelExit = false , hasEntity = false , nearWall = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , }, MovingSlime = { isFloor = true , levelExit = false , hasEntity = false , nearWall = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , }, OnWall = { hasEntity = false , isWall = true , }, OnWire = { isFloor = true , levelExit = false , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , wire = true } }, Trap = { Generic = { isFloor = true , levelExit = false , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , wire = false , noWallTallSprite = true } }, Shrine = { Generic = { isFloor = true , levelExit = false , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , nearWall = false , wire = false } }, Terrain = { Hazard = { isFloor = true , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , levelExit = false }, Exit = { isFloor = true , adjacentEntrance = false , } }, Loot = { Generic = { isFloor = true , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , wire = false , levelExit = false }, Chest = { isFloor = true , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , wire = false , levelExit = false } }, }","title":"Util.lua"},{"location":"modules/Util.lua/#utillua","text":"","title":"Util.lua"},{"location":"modules/Util.lua/#other","text":"","title":"Other"},{"location":"modules/Util.lua/#levelgenutiltilerequirements-helper-table","text":"levelGenUtil . TileRequirements = { Enemy = { Generic = { isFloor = true , levelExit = false , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , }, NotNearWall = { isFloor = true , levelExit = false , hasEntity = false , nearWall = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , }, MovingSlime = { isFloor = true , levelExit = false , hasEntity = false , nearWall = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , }, OnWall = { hasEntity = false , isWall = true , }, OnWire = { isFloor = true , levelExit = false , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , wire = true } }, Trap = { Generic = { isFloor = true , levelExit = false , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , wire = false , noWallTallSprite = true } }, Shrine = { Generic = { isFloor = true , levelExit = false , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , nearWall = false , wire = false } }, Terrain = { Hazard = { isFloor = true , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , levelExit = false }, Exit = { isFloor = true , adjacentEntrance = false , } }, Loot = { Generic = { isFloor = true , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , wire = false , levelExit = false }, Chest = { isFloor = true , hasEntity = false , adjacentEntrance = false , notCollision = collision . Group . UNSAFE , wire = false , levelExit = false } }, }","title":"levelGenUtil.TileRequirements  helper table"}]}